   1               		.file	"uart.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	uart_init
  12               	uart_init:
  13               	.LFB4:
  14               		.file 1 "uart.c"
   1:uart.c        **** /*
   2:uart.c        ****  * Author: Felix Schulze
   3:uart.c        ****  * Date:   22/02/2015
   4:uart.c        ****  *
   5:uart.c        ****  *
   6:uart.c        ****  */
   7:uart.c        **** 
   8:uart.c        **** #include <avr/io.h>
   9:uart.c        **** #include <stdlib.h>
  10:uart.c        **** #include "uart.h"
  11:uart.c        **** #include "mcp2515.h"
  12:uart.c        **** 
  13:uart.c        **** 
  14:uart.c        **** static char buffer[9];
  15:uart.c        **** 
  16:uart.c        **** void uart_init(unsigned int baudrate)
  17:uart.c        **** {
  15               		.loc 1 17 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  18:uart.c        ****     
  19:uart.c        ****     UBRRL = (unsigned char) baudrate;
  22               		.loc 1 19 0
  23 0000 89B9      		out 0x9,r24
  20:uart.c        ****     UBRRH = (unsigned char)(baudrate>>8);
  24               		.loc 1 20 0
  25 0002 90BD      		out 0x20,r25
  21:uart.c        **** 
  22:uart.c        **** 
  23:uart.c        ****     UCSRB = (1<<TXEN) | (1<<RXEN);
  26               		.loc 1 23 0
  27 0004 88E1      		ldi r24,lo8(24)
  28               	.LVL1:
  29 0006 8AB9      		out 0xa,r24
  24:uart.c        ****     UCSRC = (1<<URSEL) | (1<<UCSZ1) | (1<<UCSZ0);
  30               		.loc 1 24 0
  31 0008 86E8      		ldi r24,lo8(-122)
  32 000a 80BD      		out 0x20,r24
  33 000c 0895      		ret
  34               		.cfi_endproc
  35               	.LFE4:
  37               	.global	uart_putc
  39               	uart_putc:
  40               	.LFB5:
  25:uart.c        **** 
  26:uart.c        ****     return;
  27:uart.c        ****    
  28:uart.c        **** }
  29:uart.c        **** 
  30:uart.c        **** void uart_putc(unsigned char data)
  31:uart.c        **** {
  41               		.loc 1 31 0
  42               		.cfi_startproc
  43               	/* prologue: function */
  44               	/* frame size = 0 */
  45               	/* stack size = 0 */
  46               	.L__stack_usage = 0
  47               	.LVL2:
  48               	.L3:
  32:uart.c        ****     // uart data register empty ?
  33:uart.c        ****     while(!(UCSRA & (1<<UDRE)));
  49               		.loc 1 33 0 discriminator 1
  50 000e 5D9B      		sbis 0xb,5
  51 0010 00C0      		rjmp .L3
  34:uart.c        ****     UDR = data;
  52               		.loc 1 34 0
  53 0012 8CB9      		out 0xc,r24
  54 0014 0895      		ret
  55               		.cfi_endproc
  56               	.LFE5:
  58               	.global	uart_puts
  60               	uart_puts:
  61               	.LFB6:
  35:uart.c        **** 
  36:uart.c        ****     return;
  37:uart.c        **** }
  38:uart.c        **** 
  39:uart.c        **** void uart_puts(const char *s )
  40:uart.c        **** {
  62               		.loc 1 40 0
  63               		.cfi_startproc
  64               	.LVL3:
  65 0016 CF93      		push r28
  66               	.LCFI0:
  67               		.cfi_def_cfa_offset 3
  68               		.cfi_offset 28, -2
  69 0018 DF93      		push r29
  70               	.LCFI1:
  71               		.cfi_def_cfa_offset 4
  72               		.cfi_offset 29, -3
  73               	/* prologue: function */
  74               	/* frame size = 0 */
  75               	/* stack size = 2 */
  76               	.L__stack_usage = 2
  77 001a EC01      		movw r28,r24
  78               	.LVL4:
  79               	.L8:
  41:uart.c        ****     while (*s) 
  80               		.loc 1 41 0
  81 001c 8991      		ld r24,Y+
  82               	.LVL5:
  83 001e 8823      		tst r24
  84 0020 01F0      		breq .L10
  85               	.LVL6:
  42:uart.c        ****       uart_putc(*s++);
  86               		.loc 1 42 0
  87 0022 00D0      		rcall uart_putc
  88               	.LVL7:
  89 0024 00C0      		rjmp .L8
  90               	.LVL8:
  91               	.L10:
  92               	/* epilogue start */
  43:uart.c        **** 
  44:uart.c        ****   return;
  45:uart.c        **** 
  46:uart.c        **** }
  93               		.loc 1 46 0
  94 0026 DF91      		pop r29
  95 0028 CF91      		pop r28
  96               	.LVL9:
  97 002a 0895      		ret
  98               		.cfi_endproc
  99               	.LFE6:
 101               		.section	.rodata.str1.1,"aMS",@progbits,1
 102               	.LC0:
 103 0000 0A0D 4944 		.string	"\n\rID: 0x"
 103      3A20 3078 
 103      00
 104               	.LC1:
 105 0009 0A0D 4C65 		.string	"\n\rLength: 0x"
 105      6E67 7468 
 105      3A20 3078 
 105      00
 106               	.LC2:
 107 0016 0A0D 5254 		.string	"\n\rRTR: "
 107      523A 2000 
 108               	.LC3:
 109 001e 0A0D 4461 		.string	"\n\rData: 0x"
 109      7461 3A20 
 109      3078 00
 110               	.LC4:
 111 0029 0A0D 00   		.string	"\n\r"
 112               		.text
 113               	.global	uart_can_msg
 115               	uart_can_msg:
 116               	.LFB7:
  47:uart.c        **** 
  48:uart.c        **** void uart_can_msg(Canmsg *s_msg)
  49:uart.c        **** {
 117               		.loc 1 49 0
 118               		.cfi_startproc
 119               	.LVL10:
 120 002c EF92      		push r14
 121               	.LCFI2:
 122               		.cfi_def_cfa_offset 3
 123               		.cfi_offset 14, -2
 124 002e FF92      		push r15
 125               	.LCFI3:
 126               		.cfi_def_cfa_offset 4
 127               		.cfi_offset 15, -3
 128 0030 0F93      		push r16
 129               	.LCFI4:
 130               		.cfi_def_cfa_offset 5
 131               		.cfi_offset 16, -4
 132 0032 1F93      		push r17
 133               	.LCFI5:
 134               		.cfi_def_cfa_offset 6
 135               		.cfi_offset 17, -5
 136 0034 CF93      		push r28
 137               	.LCFI6:
 138               		.cfi_def_cfa_offset 7
 139               		.cfi_offset 28, -6
 140 0036 DF93      		push r29
 141               	.LCFI7:
 142               		.cfi_def_cfa_offset 8
 143               		.cfi_offset 29, -7
 144               	/* prologue: function */
 145               	/* frame size = 0 */
 146               	/* stack size = 6 */
 147               	.L__stack_usage = 6
 148 0038 EC01      		movw r28,r24
  50:uart.c        ****     uart_puts("\n\rID: 0x");
 149               		.loc 1 50 0
 150 003a 80E0      		ldi r24,lo8(.LC0)
 151 003c 90E0      		ldi r25,hi8(.LC0)
 152               	.LVL11:
 153 003e 00D0      		rcall uart_puts
 154               	.LVL12:
 155               	.LBB19:
 156               	.LBB20:
 157               		.file 2 "/usr/avr/include/stdlib.h"
   1:/usr/avr/include/stdlib.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/stdlib.h ****    Copyright (c) 2004,2007 Joerg Wunsch
   3:/usr/avr/include/stdlib.h **** 
   4:/usr/avr/include/stdlib.h ****    Portions of documentation Copyright (c) 1990, 1991, 1993, 1994
   5:/usr/avr/include/stdlib.h ****    The Regents of the University of California.
   6:/usr/avr/include/stdlib.h **** 
   7:/usr/avr/include/stdlib.h ****    All rights reserved.
   8:/usr/avr/include/stdlib.h **** 
   9:/usr/avr/include/stdlib.h ****    Redistribution and use in source and binary forms, with or without
  10:/usr/avr/include/stdlib.h ****    modification, are permitted provided that the following conditions are met:
  11:/usr/avr/include/stdlib.h **** 
  12:/usr/avr/include/stdlib.h ****    * Redistributions of source code must retain the above copyright
  13:/usr/avr/include/stdlib.h ****      notice, this list of conditions and the following disclaimer.
  14:/usr/avr/include/stdlib.h **** 
  15:/usr/avr/include/stdlib.h ****    * Redistributions in binary form must reproduce the above copyright
  16:/usr/avr/include/stdlib.h ****      notice, this list of conditions and the following disclaimer in
  17:/usr/avr/include/stdlib.h ****      the documentation and/or other materials provided with the
  18:/usr/avr/include/stdlib.h ****      distribution.
  19:/usr/avr/include/stdlib.h **** 
  20:/usr/avr/include/stdlib.h ****    * Neither the name of the copyright holders nor the names of
  21:/usr/avr/include/stdlib.h ****      contributors may be used to endorse or promote products derived
  22:/usr/avr/include/stdlib.h ****      from this software without specific prior written permission.
  23:/usr/avr/include/stdlib.h **** 
  24:/usr/avr/include/stdlib.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  25:/usr/avr/include/stdlib.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  26:/usr/avr/include/stdlib.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  27:/usr/avr/include/stdlib.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  28:/usr/avr/include/stdlib.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  29:/usr/avr/include/stdlib.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  30:/usr/avr/include/stdlib.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  31:/usr/avr/include/stdlib.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  32:/usr/avr/include/stdlib.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  33:/usr/avr/include/stdlib.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  34:/usr/avr/include/stdlib.h ****   POSSIBILITY OF SUCH DAMAGE.
  35:/usr/avr/include/stdlib.h **** 
  36:/usr/avr/include/stdlib.h ****   $Id: stdlib.h 2443 2014-08-11 21:50:59Z joerg_wunsch $
  37:/usr/avr/include/stdlib.h **** */
  38:/usr/avr/include/stdlib.h **** 
  39:/usr/avr/include/stdlib.h **** #ifndef _STDLIB_H_
  40:/usr/avr/include/stdlib.h **** #define	_STDLIB_H_ 1
  41:/usr/avr/include/stdlib.h **** 
  42:/usr/avr/include/stdlib.h **** #ifndef __ASSEMBLER__
  43:/usr/avr/include/stdlib.h **** 
  44:/usr/avr/include/stdlib.h **** #define __need_NULL
  45:/usr/avr/include/stdlib.h **** #define __need_size_t
  46:/usr/avr/include/stdlib.h **** #define __need_wchar_t
  47:/usr/avr/include/stdlib.h **** #include <stddef.h>
  48:/usr/avr/include/stdlib.h **** 
  49:/usr/avr/include/stdlib.h **** #ifndef __ptr_t
  50:/usr/avr/include/stdlib.h **** #define __ptr_t void *
  51:/usr/avr/include/stdlib.h **** #endif
  52:/usr/avr/include/stdlib.h **** 
  53:/usr/avr/include/stdlib.h **** #ifdef __cplusplus
  54:/usr/avr/include/stdlib.h **** extern "C" {
  55:/usr/avr/include/stdlib.h **** #endif
  56:/usr/avr/include/stdlib.h **** 
  57:/usr/avr/include/stdlib.h **** /** \file */
  58:/usr/avr/include/stdlib.h **** 
  59:/usr/avr/include/stdlib.h **** /** \defgroup avr_stdlib <stdlib.h>: General utilities
  60:/usr/avr/include/stdlib.h ****     \code #include <stdlib.h> \endcode
  61:/usr/avr/include/stdlib.h **** 
  62:/usr/avr/include/stdlib.h ****     This file declares some basic C macros and functions as
  63:/usr/avr/include/stdlib.h ****     defined by the ISO standard, plus some AVR-specific extensions.
  64:/usr/avr/include/stdlib.h **** */
  65:/usr/avr/include/stdlib.h **** 
  66:/usr/avr/include/stdlib.h **** /*@{*/
  67:/usr/avr/include/stdlib.h **** /** Result type for function div(). */
  68:/usr/avr/include/stdlib.h **** typedef struct {
  69:/usr/avr/include/stdlib.h **** 	int quot;                   /**< The Quotient. */
  70:/usr/avr/include/stdlib.h **** 	int rem;                    /**< The Remainder. */
  71:/usr/avr/include/stdlib.h **** } div_t;
  72:/usr/avr/include/stdlib.h **** 
  73:/usr/avr/include/stdlib.h **** /** Result type for function ldiv(). */
  74:/usr/avr/include/stdlib.h **** typedef struct {
  75:/usr/avr/include/stdlib.h **** 	long quot;                  /**< The Quotient. */
  76:/usr/avr/include/stdlib.h **** 	long rem;                   /**< The Remainder. */
  77:/usr/avr/include/stdlib.h **** } ldiv_t;
  78:/usr/avr/include/stdlib.h **** 
  79:/usr/avr/include/stdlib.h **** /** Comparision function type for qsort(), just for convenience. */
  80:/usr/avr/include/stdlib.h **** typedef int (*__compar_fn_t)(const void *, const void *);
  81:/usr/avr/include/stdlib.h **** 
  82:/usr/avr/include/stdlib.h **** #ifndef __DOXYGEN__
  83:/usr/avr/include/stdlib.h **** 
  84:/usr/avr/include/stdlib.h **** #ifndef __ATTR_CONST__
  85:/usr/avr/include/stdlib.h **** # define __ATTR_CONST__ __attribute__((__const__))
  86:/usr/avr/include/stdlib.h **** #endif
  87:/usr/avr/include/stdlib.h **** 
  88:/usr/avr/include/stdlib.h **** #ifndef __ATTR_MALLOC__
  89:/usr/avr/include/stdlib.h **** # define __ATTR_MALLOC__ __attribute__((__malloc__))
  90:/usr/avr/include/stdlib.h **** #endif
  91:/usr/avr/include/stdlib.h **** 
  92:/usr/avr/include/stdlib.h **** #ifndef __ATTR_NORETURN__
  93:/usr/avr/include/stdlib.h **** # define __ATTR_NORETURN__ __attribute__((__noreturn__))
  94:/usr/avr/include/stdlib.h **** #endif
  95:/usr/avr/include/stdlib.h **** 
  96:/usr/avr/include/stdlib.h **** #ifndef __ATTR_PURE__
  97:/usr/avr/include/stdlib.h **** # define __ATTR_PURE__ __attribute__((__pure__))
  98:/usr/avr/include/stdlib.h **** #endif
  99:/usr/avr/include/stdlib.h **** 
 100:/usr/avr/include/stdlib.h **** #ifndef	__ATTR_GNU_INLINE__
 101:/usr/avr/include/stdlib.h **** # ifdef  __GNUC_STDC_INLINE__
 102:/usr/avr/include/stdlib.h **** #  define __ATTR_GNU_INLINE__   __attribute__((__gnu_inline__))
 103:/usr/avr/include/stdlib.h **** # else
 104:/usr/avr/include/stdlib.h **** #  define __ATTR_GNU_INLINE__
 105:/usr/avr/include/stdlib.h **** # endif
 106:/usr/avr/include/stdlib.h **** #endif
 107:/usr/avr/include/stdlib.h **** 
 108:/usr/avr/include/stdlib.h **** #endif
 109:/usr/avr/include/stdlib.h **** 
 110:/usr/avr/include/stdlib.h **** /** The abort() function causes abnormal program termination to occur.
 111:/usr/avr/include/stdlib.h ****     This realization disables interrupts and jumps to _exit() function
 112:/usr/avr/include/stdlib.h ****     with argument equal to 1. In the limited AVR environment, execution is
 113:/usr/avr/include/stdlib.h ****     effectively halted by entering an infinite loop. */
 114:/usr/avr/include/stdlib.h **** extern void abort(void) __ATTR_NORETURN__;
 115:/usr/avr/include/stdlib.h **** 
 116:/usr/avr/include/stdlib.h **** /** The abs() function computes the absolute value of the integer \c i.
 117:/usr/avr/include/stdlib.h ****    \note The abs() and labs() functions are builtins of gcc.
 118:/usr/avr/include/stdlib.h **** */
 119:/usr/avr/include/stdlib.h **** extern int abs(int __i) __ATTR_CONST__;
 120:/usr/avr/include/stdlib.h **** #ifndef __DOXYGEN__
 121:/usr/avr/include/stdlib.h **** #define	abs(__i) __builtin_abs(__i)
 122:/usr/avr/include/stdlib.h **** #endif
 123:/usr/avr/include/stdlib.h **** 
 124:/usr/avr/include/stdlib.h **** /** The labs() function computes the absolute value of the long integer
 125:/usr/avr/include/stdlib.h ****     \c i.
 126:/usr/avr/include/stdlib.h ****    \note The abs() and labs() functions are builtins of gcc.
 127:/usr/avr/include/stdlib.h **** */
 128:/usr/avr/include/stdlib.h **** extern long labs(long __i) __ATTR_CONST__;
 129:/usr/avr/include/stdlib.h **** #ifndef __DOXYGEN__
 130:/usr/avr/include/stdlib.h **** #define labs(__i) __builtin_labs(__i)
 131:/usr/avr/include/stdlib.h **** #endif
 132:/usr/avr/include/stdlib.h **** 
 133:/usr/avr/include/stdlib.h **** /**
 134:/usr/avr/include/stdlib.h ****      The bsearch() function searches an array of \c nmemb objects, the
 135:/usr/avr/include/stdlib.h ****      initial member of which is pointed to by \c base, for a member
 136:/usr/avr/include/stdlib.h ****      that matches the object pointed to by \c key.  The size of each
 137:/usr/avr/include/stdlib.h ****      member of the array is specified by \c size.
 138:/usr/avr/include/stdlib.h **** 
 139:/usr/avr/include/stdlib.h ****      The contents of the array should be in ascending sorted order
 140:/usr/avr/include/stdlib.h ****      according to the comparison function referenced by \c compar.
 141:/usr/avr/include/stdlib.h ****      The \c compar routine is expected to have two arguments which
 142:/usr/avr/include/stdlib.h ****      point to the key object and to an array member, in that order,
 143:/usr/avr/include/stdlib.h ****      and should return an integer less than, equal to, or greater than
 144:/usr/avr/include/stdlib.h ****      zero if the key object is found, respectively, to be less than,
 145:/usr/avr/include/stdlib.h ****      to match, or be greater than the array member.
 146:/usr/avr/include/stdlib.h **** 
 147:/usr/avr/include/stdlib.h ****      The bsearch() function returns a pointer to a matching member of
 148:/usr/avr/include/stdlib.h ****      the array, or a null pointer if no match is found.  If two
 149:/usr/avr/include/stdlib.h ****      members compare as equal, which member is matched is unspecified.
 150:/usr/avr/include/stdlib.h **** */
 151:/usr/avr/include/stdlib.h **** extern void *bsearch(const void *__key, const void *__base, size_t __nmemb,
 152:/usr/avr/include/stdlib.h **** 		     size_t __size, int (*__compar)(const void *, const void *));
 153:/usr/avr/include/stdlib.h **** 
 154:/usr/avr/include/stdlib.h **** /* __divmodhi4 and __divmodsi4 from libgcc.a */
 155:/usr/avr/include/stdlib.h **** /**
 156:/usr/avr/include/stdlib.h ****      The div() function computes the value \c num/denom and returns
 157:/usr/avr/include/stdlib.h ****      the quotient and remainder in a structure named \c div_t that
 158:/usr/avr/include/stdlib.h ****      contains two int members named \c quot and \c rem.
 159:/usr/avr/include/stdlib.h **** */
 160:/usr/avr/include/stdlib.h **** extern div_t div(int __num, int __denom) __asm__("__divmodhi4") __ATTR_CONST__;
 161:/usr/avr/include/stdlib.h **** /**
 162:/usr/avr/include/stdlib.h ****      The ldiv() function computes the value \c num/denom and returns
 163:/usr/avr/include/stdlib.h ****      the quotient and remainder in a structure named \c ldiv_t that
 164:/usr/avr/include/stdlib.h ****      contains two long integer members named \c quot and \c rem.
 165:/usr/avr/include/stdlib.h **** */
 166:/usr/avr/include/stdlib.h **** extern ldiv_t ldiv(long __num, long __denom) __asm__("__divmodsi4") __ATTR_CONST__;
 167:/usr/avr/include/stdlib.h **** 
 168:/usr/avr/include/stdlib.h **** /**
 169:/usr/avr/include/stdlib.h ****      The qsort() function is a modified partition-exchange sort, or
 170:/usr/avr/include/stdlib.h ****      quicksort.
 171:/usr/avr/include/stdlib.h **** 
 172:/usr/avr/include/stdlib.h ****      The qsort() function sorts an array of \c nmemb objects, the
 173:/usr/avr/include/stdlib.h ****      initial member of which is pointed to by \c base.  The size of
 174:/usr/avr/include/stdlib.h ****      each object is specified by \c size.  The contents of the array
 175:/usr/avr/include/stdlib.h ****      base are sorted in ascending order according to a comparison
 176:/usr/avr/include/stdlib.h ****      function pointed to by \c compar, which requires two arguments
 177:/usr/avr/include/stdlib.h ****      pointing to the objects being compared.
 178:/usr/avr/include/stdlib.h **** 
 179:/usr/avr/include/stdlib.h ****      The comparison function must return an integer less than, equal
 180:/usr/avr/include/stdlib.h ****      to, or greater than zero if the first argument is considered to
 181:/usr/avr/include/stdlib.h ****      be respectively less than, equal to, or greater than the second.
 182:/usr/avr/include/stdlib.h **** */
 183:/usr/avr/include/stdlib.h **** extern void qsort(void *__base, size_t __nmemb, size_t __size,
 184:/usr/avr/include/stdlib.h **** 		  __compar_fn_t __compar);
 185:/usr/avr/include/stdlib.h **** 
 186:/usr/avr/include/stdlib.h **** /**
 187:/usr/avr/include/stdlib.h ****     The strtol() function converts the string in \c nptr to a long
 188:/usr/avr/include/stdlib.h ****     value.  The conversion is done according to the given base, which
 189:/usr/avr/include/stdlib.h ****     must be between 2 and 36 inclusive, or be the special value 0.
 190:/usr/avr/include/stdlib.h **** 
 191:/usr/avr/include/stdlib.h ****     The string may begin with an arbitrary amount of white space (as
 192:/usr/avr/include/stdlib.h ****     determined by isspace()) followed by a single optional \c '+' or \c '-'
 193:/usr/avr/include/stdlib.h ****     sign.  If \c base is zero or 16, the string may then include a
 194:/usr/avr/include/stdlib.h ****     \c "0x" prefix, and the number will be read in base 16; otherwise,
 195:/usr/avr/include/stdlib.h ****     a zero base is taken as 10 (decimal) unless the next character is
 196:/usr/avr/include/stdlib.h ****     \c '0', in which case it is taken as 8 (octal).
 197:/usr/avr/include/stdlib.h **** 
 198:/usr/avr/include/stdlib.h ****     The remainder of the string is converted to a long value in the
 199:/usr/avr/include/stdlib.h ****     obvious manner, stopping at the first character which is not a
 200:/usr/avr/include/stdlib.h ****     valid digit in the given base.  (In bases above 10, the letter \c 'A'
 201:/usr/avr/include/stdlib.h ****     in either upper or lower case represents 10, \c 'B' represents 11,
 202:/usr/avr/include/stdlib.h ****     and so forth, with \c 'Z' representing 35.)
 203:/usr/avr/include/stdlib.h **** 
 204:/usr/avr/include/stdlib.h ****     If \c endptr is not NULL, strtol() stores the address of the first
 205:/usr/avr/include/stdlib.h ****     invalid character in \c *endptr.  If there were no digits at all,
 206:/usr/avr/include/stdlib.h ****     however, strtol() stores the original value of \c nptr in \c
 207:/usr/avr/include/stdlib.h ****     *endptr.  (Thus, if \c *nptr is not \c '\\0' but \c **endptr is \c '\\0'
 208:/usr/avr/include/stdlib.h ****     on return, the entire string was valid.)
 209:/usr/avr/include/stdlib.h **** 
 210:/usr/avr/include/stdlib.h ****     The strtol() function returns the result of the conversion, unless
 211:/usr/avr/include/stdlib.h ****     the value would underflow or overflow.  If no conversion could be
 212:/usr/avr/include/stdlib.h ****     performed, 0 is returned.  If an overflow or underflow occurs, \c
 213:/usr/avr/include/stdlib.h ****     errno is set to \ref avr_errno "ERANGE" and the function return value
 214:/usr/avr/include/stdlib.h ****     is clamped to \c LONG_MIN or \c LONG_MAX, respectively.
 215:/usr/avr/include/stdlib.h **** */
 216:/usr/avr/include/stdlib.h **** extern long strtol(const char *__nptr, char **__endptr, int __base);
 217:/usr/avr/include/stdlib.h **** 
 218:/usr/avr/include/stdlib.h **** /**
 219:/usr/avr/include/stdlib.h ****     The strtoul() function converts the string in \c nptr to an
 220:/usr/avr/include/stdlib.h ****     unsigned long value.  The conversion is done according to the
 221:/usr/avr/include/stdlib.h ****     given base, which must be between 2 and 36 inclusive, or be the
 222:/usr/avr/include/stdlib.h ****     special value 0.
 223:/usr/avr/include/stdlib.h **** 
 224:/usr/avr/include/stdlib.h ****     The string may begin with an arbitrary amount of white space (as
 225:/usr/avr/include/stdlib.h ****     determined by isspace()) followed by a single optional \c '+' or \c '-'
 226:/usr/avr/include/stdlib.h ****     sign.  If \c base is zero or 16, the string may then include a
 227:/usr/avr/include/stdlib.h ****     \c "0x" prefix, and the number will be read in base 16; otherwise,
 228:/usr/avr/include/stdlib.h ****     a zero base is taken as 10 (decimal) unless the next character is
 229:/usr/avr/include/stdlib.h ****     \c '0', in which case it is taken as 8 (octal).
 230:/usr/avr/include/stdlib.h **** 
 231:/usr/avr/include/stdlib.h ****     The remainder of the string is converted to an unsigned long value
 232:/usr/avr/include/stdlib.h ****     in the obvious manner, stopping at the first character which is
 233:/usr/avr/include/stdlib.h ****     not a valid digit in the given base.  (In bases above 10, the
 234:/usr/avr/include/stdlib.h ****     letter \c 'A' in either upper or lower case represents 10, \c 'B'
 235:/usr/avr/include/stdlib.h ****     represents 11, and so forth, with \c 'Z' representing 35.)
 236:/usr/avr/include/stdlib.h **** 
 237:/usr/avr/include/stdlib.h ****     If \c endptr is not NULL, strtoul() stores the address of the first
 238:/usr/avr/include/stdlib.h ****     invalid character in \c *endptr.  If there were no digits at all,
 239:/usr/avr/include/stdlib.h ****     however, strtoul() stores the original value of \c nptr in \c
 240:/usr/avr/include/stdlib.h ****     *endptr.  (Thus, if \c *nptr is not \c '\\0' but \c **endptr is \c '\\0'
 241:/usr/avr/include/stdlib.h ****     on return, the entire string was valid.)
 242:/usr/avr/include/stdlib.h **** 
 243:/usr/avr/include/stdlib.h ****     The strtoul() function return either the result of the conversion
 244:/usr/avr/include/stdlib.h ****     or, if there was a leading minus sign, the negation of the result
 245:/usr/avr/include/stdlib.h ****     of the conversion, unless the original (non-negated) value would
 246:/usr/avr/include/stdlib.h ****     overflow; in the latter case, strtoul() returns ULONG_MAX, and \c
 247:/usr/avr/include/stdlib.h ****     errno is set to \ref avr_errno "ERANGE".  If no conversion could 
 248:/usr/avr/include/stdlib.h ****     be performed, 0 is returned.
 249:/usr/avr/include/stdlib.h **** */
 250:/usr/avr/include/stdlib.h **** extern unsigned long strtoul(const char *__nptr, char **__endptr, int __base);
 251:/usr/avr/include/stdlib.h **** 
 252:/usr/avr/include/stdlib.h **** /**
 253:/usr/avr/include/stdlib.h ****     The atol() function converts the initial portion of the string
 254:/usr/avr/include/stdlib.h ****     pointed to by \p s to long integer representation. In contrast to
 255:/usr/avr/include/stdlib.h **** 
 256:/usr/avr/include/stdlib.h ****         \code strtol(s, (char **)NULL, 10); \endcode
 257:/usr/avr/include/stdlib.h **** 
 258:/usr/avr/include/stdlib.h ****     this function does not detect overflow (\c errno is not changed and
 259:/usr/avr/include/stdlib.h ****     the result value is not predictable), uses smaller memory (flash and
 260:/usr/avr/include/stdlib.h ****     stack) and works more quickly.
 261:/usr/avr/include/stdlib.h **** */
 262:/usr/avr/include/stdlib.h **** extern long atol(const char *__s) __ATTR_PURE__;
 263:/usr/avr/include/stdlib.h **** 
 264:/usr/avr/include/stdlib.h **** /**
 265:/usr/avr/include/stdlib.h ****     The atoi() function converts the initial portion of the string
 266:/usr/avr/include/stdlib.h ****     pointed to by \p s to integer representation. In contrast to
 267:/usr/avr/include/stdlib.h **** 
 268:/usr/avr/include/stdlib.h ****         \code (int)strtol(s, (char **)NULL, 10); \endcode
 269:/usr/avr/include/stdlib.h **** 
 270:/usr/avr/include/stdlib.h ****     this function does not detect overflow (\c errno is not changed and
 271:/usr/avr/include/stdlib.h ****     the result value is not predictable), uses smaller memory (flash and
 272:/usr/avr/include/stdlib.h ****     stack) and works more quickly.
 273:/usr/avr/include/stdlib.h **** */
 274:/usr/avr/include/stdlib.h **** extern int atoi(const char *__s) __ATTR_PURE__;
 275:/usr/avr/include/stdlib.h **** 
 276:/usr/avr/include/stdlib.h **** /**
 277:/usr/avr/include/stdlib.h ****    The exit() function terminates the application.  Since there is no
 278:/usr/avr/include/stdlib.h ****    environment to return to, \c status is ignored, and code execution
 279:/usr/avr/include/stdlib.h ****    will eventually reach an infinite loop, thereby effectively halting
 280:/usr/avr/include/stdlib.h ****    all code processing.  Before entering the infinite loop, interrupts
 281:/usr/avr/include/stdlib.h ****    are globally disabled.
 282:/usr/avr/include/stdlib.h **** 
 283:/usr/avr/include/stdlib.h ****    In a C++ context, global destructors will be called before halting
 284:/usr/avr/include/stdlib.h ****    execution.
 285:/usr/avr/include/stdlib.h **** */
 286:/usr/avr/include/stdlib.h **** extern void exit(int __status) __ATTR_NORETURN__;
 287:/usr/avr/include/stdlib.h **** 
 288:/usr/avr/include/stdlib.h **** /**
 289:/usr/avr/include/stdlib.h ****    The malloc() function allocates \c size bytes of memory.
 290:/usr/avr/include/stdlib.h ****    If malloc() fails, a NULL pointer is returned.
 291:/usr/avr/include/stdlib.h **** 
 292:/usr/avr/include/stdlib.h ****    Note that malloc() does \e not initialize the returned memory to
 293:/usr/avr/include/stdlib.h ****    zero bytes.
 294:/usr/avr/include/stdlib.h **** 
 295:/usr/avr/include/stdlib.h ****    See the chapter about \ref malloc "malloc() usage" for implementation
 296:/usr/avr/include/stdlib.h ****    details.
 297:/usr/avr/include/stdlib.h **** */
 298:/usr/avr/include/stdlib.h **** extern void *malloc(size_t __size) __ATTR_MALLOC__;
 299:/usr/avr/include/stdlib.h **** 
 300:/usr/avr/include/stdlib.h **** /**
 301:/usr/avr/include/stdlib.h ****    The free() function causes the allocated memory referenced by \c
 302:/usr/avr/include/stdlib.h ****    ptr to be made available for future allocations.  If \c ptr is
 303:/usr/avr/include/stdlib.h ****    NULL, no action occurs.
 304:/usr/avr/include/stdlib.h **** */
 305:/usr/avr/include/stdlib.h **** extern void free(void *__ptr);
 306:/usr/avr/include/stdlib.h **** 
 307:/usr/avr/include/stdlib.h **** /**
 308:/usr/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 309:/usr/avr/include/stdlib.h **** */
 310:/usr/avr/include/stdlib.h **** extern size_t __malloc_margin;
 311:/usr/avr/include/stdlib.h **** 
 312:/usr/avr/include/stdlib.h **** /**
 313:/usr/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 314:/usr/avr/include/stdlib.h **** */
 315:/usr/avr/include/stdlib.h **** extern char *__malloc_heap_start;
 316:/usr/avr/include/stdlib.h **** 
 317:/usr/avr/include/stdlib.h **** /**
 318:/usr/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 319:/usr/avr/include/stdlib.h **** */
 320:/usr/avr/include/stdlib.h **** extern char *__malloc_heap_end;
 321:/usr/avr/include/stdlib.h **** 
 322:/usr/avr/include/stdlib.h **** /**
 323:/usr/avr/include/stdlib.h ****    Allocate \c nele elements of \c size each.  Identical to calling
 324:/usr/avr/include/stdlib.h ****    \c malloc() using <tt>nele * size</tt> as argument, except the
 325:/usr/avr/include/stdlib.h ****    allocated memory will be cleared to zero.
 326:/usr/avr/include/stdlib.h **** */
 327:/usr/avr/include/stdlib.h **** extern void *calloc(size_t __nele, size_t __size) __ATTR_MALLOC__;
 328:/usr/avr/include/stdlib.h **** 
 329:/usr/avr/include/stdlib.h **** /**
 330:/usr/avr/include/stdlib.h ****    The realloc() function tries to change the size of the region
 331:/usr/avr/include/stdlib.h ****    allocated at \c ptr to the new \c size value.  It returns a
 332:/usr/avr/include/stdlib.h ****    pointer to the new region.  The returned pointer might be the
 333:/usr/avr/include/stdlib.h ****    same as the old pointer, or a pointer to a completely different
 334:/usr/avr/include/stdlib.h ****    region.
 335:/usr/avr/include/stdlib.h **** 
 336:/usr/avr/include/stdlib.h ****    The contents of the returned region up to either the old or the new
 337:/usr/avr/include/stdlib.h ****    size value (whatever is less) will be identical to the contents of
 338:/usr/avr/include/stdlib.h ****    the old region, even in case a new region had to be allocated.
 339:/usr/avr/include/stdlib.h **** 
 340:/usr/avr/include/stdlib.h ****    It is acceptable to pass \c ptr as NULL, in which case realloc()
 341:/usr/avr/include/stdlib.h ****    will behave identical to malloc().
 342:/usr/avr/include/stdlib.h **** 
 343:/usr/avr/include/stdlib.h ****    If the new memory cannot be allocated, realloc() returns NULL, and
 344:/usr/avr/include/stdlib.h ****    the region at \c ptr will not be changed.
 345:/usr/avr/include/stdlib.h **** */
 346:/usr/avr/include/stdlib.h **** extern void *realloc(void *__ptr, size_t __size) __ATTR_MALLOC__;
 347:/usr/avr/include/stdlib.h **** 
 348:/usr/avr/include/stdlib.h **** extern double strtod(const char *__nptr, char **__endptr);
 349:/usr/avr/include/stdlib.h **** 
 350:/usr/avr/include/stdlib.h **** extern double atof(const char *__nptr);
 351:/usr/avr/include/stdlib.h **** 
 352:/usr/avr/include/stdlib.h **** /** Highest number that can be generated by rand(). */
 353:/usr/avr/include/stdlib.h **** #define	RAND_MAX 0x7FFF
 354:/usr/avr/include/stdlib.h **** 
 355:/usr/avr/include/stdlib.h **** /**
 356:/usr/avr/include/stdlib.h ****      The rand() function computes a sequence of pseudo-random integers in the
 357:/usr/avr/include/stdlib.h ****      range of 0 to \c RAND_MAX (as defined by the header file <stdlib.h>).
 358:/usr/avr/include/stdlib.h **** 
 359:/usr/avr/include/stdlib.h ****      The srand() function sets its argument \c seed as the seed for a new
 360:/usr/avr/include/stdlib.h ****      sequence of pseudo-random numbers to be returned by rand().  These
 361:/usr/avr/include/stdlib.h ****      sequences are repeatable by calling srand() with the same seed value.
 362:/usr/avr/include/stdlib.h **** 
 363:/usr/avr/include/stdlib.h ****      If no seed value is provided, the functions are automatically seeded with
 364:/usr/avr/include/stdlib.h ****      a value of 1.
 365:/usr/avr/include/stdlib.h **** 
 366:/usr/avr/include/stdlib.h ****      In compliance with the C standard, these functions operate on
 367:/usr/avr/include/stdlib.h ****      \c int arguments.  Since the underlying algorithm already uses
 368:/usr/avr/include/stdlib.h ****      32-bit calculations, this causes a loss of precision.  See
 369:/usr/avr/include/stdlib.h ****      \c random() for an alternate set of functions that retains full
 370:/usr/avr/include/stdlib.h ****      32-bit precision.
 371:/usr/avr/include/stdlib.h **** */
 372:/usr/avr/include/stdlib.h **** extern int rand(void);
 373:/usr/avr/include/stdlib.h **** /**
 374:/usr/avr/include/stdlib.h ****    Pseudo-random number generator seeding; see rand().
 375:/usr/avr/include/stdlib.h **** */
 376:/usr/avr/include/stdlib.h **** extern void srand(unsigned int __seed);
 377:/usr/avr/include/stdlib.h **** 
 378:/usr/avr/include/stdlib.h **** /**
 379:/usr/avr/include/stdlib.h ****    Variant of rand() that stores the context in the user-supplied
 380:/usr/avr/include/stdlib.h ****    variable located at \c ctx instead of a static library variable
 381:/usr/avr/include/stdlib.h ****    so the function becomes re-entrant.
 382:/usr/avr/include/stdlib.h **** */
 383:/usr/avr/include/stdlib.h **** extern int rand_r(unsigned long *__ctx);
 384:/usr/avr/include/stdlib.h **** /*@}*/
 385:/usr/avr/include/stdlib.h **** 
 386:/usr/avr/include/stdlib.h **** /*@{*/
 387:/usr/avr/include/stdlib.h **** /** \name Non-standard (i.e. non-ISO C) functions.
 388:/usr/avr/include/stdlib.h ****  \ingroup avr_stdlib
 389:/usr/avr/include/stdlib.h **** */
 390:/usr/avr/include/stdlib.h **** /**
 391:/usr/avr/include/stdlib.h ****    \brief Convert an integer to a string.
 392:/usr/avr/include/stdlib.h **** 
 393:/usr/avr/include/stdlib.h ****    The function itoa() converts the integer value from \c val into an
 394:/usr/avr/include/stdlib.h ****    ASCII representation that will be stored under \c s.  The caller
 395:/usr/avr/include/stdlib.h ****    is responsible for providing sufficient storage in \c s.
 396:/usr/avr/include/stdlib.h **** 
 397:/usr/avr/include/stdlib.h ****    \note The minimal size of the buffer \c s depends on the choice of
 398:/usr/avr/include/stdlib.h ****    radix. For example, if the radix is 2 (binary), you need to supply a buffer
 399:/usr/avr/include/stdlib.h ****    with a minimal length of 8 * sizeof (int) + 1 characters, i.e. one
 400:/usr/avr/include/stdlib.h ****    character for each bit plus one for the string terminator. Using a larger
 401:/usr/avr/include/stdlib.h ****    radix will require a smaller minimal buffer size.
 402:/usr/avr/include/stdlib.h **** 
 403:/usr/avr/include/stdlib.h ****    \warning If the buffer is too small, you risk a buffer overflow.
 404:/usr/avr/include/stdlib.h **** 
 405:/usr/avr/include/stdlib.h ****    Conversion is done using the \c radix as base, which may be a
 406:/usr/avr/include/stdlib.h ****    number between 2 (binary conversion) and up to 36.  If \c radix
 407:/usr/avr/include/stdlib.h ****    is greater than 10, the next digit after \c '9' will be the letter
 408:/usr/avr/include/stdlib.h ****    \c 'a'.
 409:/usr/avr/include/stdlib.h ****     
 410:/usr/avr/include/stdlib.h ****     If radix is 10 and val is negative, a minus sign will be prepended.
 411:/usr/avr/include/stdlib.h **** 
 412:/usr/avr/include/stdlib.h ****    The itoa() function returns the pointer passed as \c s.
 413:/usr/avr/include/stdlib.h **** */
 414:/usr/avr/include/stdlib.h **** #ifdef  __DOXYGEN__
 415:/usr/avr/include/stdlib.h **** extern char *itoa(int val, char *s, int radix);
 416:/usr/avr/include/stdlib.h **** #else
 417:/usr/avr/include/stdlib.h **** extern __inline__ __ATTR_GNU_INLINE__
 418:/usr/avr/include/stdlib.h **** char *itoa (int __val, char *__s, int __radix)
 419:/usr/avr/include/stdlib.h **** {
 420:/usr/avr/include/stdlib.h ****     if (!__builtin_constant_p (__radix)) {
 421:/usr/avr/include/stdlib.h **** 	extern char *__itoa (int, char *, int);
 422:/usr/avr/include/stdlib.h **** 	return __itoa (__val, __s, __radix);
 423:/usr/avr/include/stdlib.h ****     } else if (__radix < 2 || __radix > 36) {
 424:/usr/avr/include/stdlib.h **** 	*__s = 0;
 425:/usr/avr/include/stdlib.h **** 	return __s;
 426:/usr/avr/include/stdlib.h ****     } else {
 427:/usr/avr/include/stdlib.h **** 	extern char *__itoa_ncheck (int, char *, unsigned char);
 428:/usr/avr/include/stdlib.h **** 	return __itoa_ncheck (__val, __s, __radix);
 158               		.loc 2 428 0
 159 0040 40E1      		ldi r20,lo8(16)
 160 0042 60E0      		ldi r22,lo8(buffer)
 161 0044 70E0      		ldi r23,hi8(buffer)
 162 0046 8881      		ld r24,Y
 163 0048 9981      		ldd r25,Y+1
 164 004a 00D0      		rcall __itoa_ncheck
 165               	.LVL13:
 166               	.LBE20:
 167               	.LBE19:
  51:uart.c        ****     itoa(s_msg->id,buffer, 16);
  52:uart.c        ****     uart_puts(buffer);
 168               		.loc 1 52 0
 169 004c 80E0      		ldi r24,lo8(buffer)
 170 004e 90E0      		ldi r25,hi8(buffer)
 171 0050 00D0      		rcall uart_puts
 172               	.LVL14:
  53:uart.c        ****     uart_puts("\n\rLength: 0x");
 173               		.loc 1 53 0
 174 0052 80E0      		ldi r24,lo8(.LC1)
 175 0054 90E0      		ldi r25,hi8(.LC1)
 176 0056 00D0      		rcall uart_puts
 177               	.LVL15:
  54:uart.c        ****     itoa(s_msg->length,buffer, 16);
 178               		.loc 1 54 0
 179 0058 8D81      		ldd r24,Y+5
 180               	.LBB21:
 181               	.LBB22:
 182               		.loc 2 428 0
 183 005a 40E1      		ldi r20,lo8(16)
 184 005c 60E0      		ldi r22,lo8(buffer)
 185 005e 70E0      		ldi r23,hi8(buffer)
 186 0060 90E0      		ldi r25,0
 187 0062 00D0      		rcall __itoa_ncheck
 188               	.LVL16:
 189               	.LBE22:
 190               	.LBE21:
  55:uart.c        ****     uart_puts(buffer);
 191               		.loc 1 55 0
 192 0064 80E0      		ldi r24,lo8(buffer)
 193 0066 90E0      		ldi r25,hi8(buffer)
 194 0068 00D0      		rcall uart_puts
 195               	.LVL17:
  56:uart.c        **** 
  57:uart.c        ****     uart_puts("\n\rRTR: ");
 196               		.loc 1 57 0
 197 006a 80E0      		ldi r24,lo8(.LC2)
 198 006c 90E0      		ldi r25,hi8(.LC2)
 199 006e 00D0      		rcall uart_puts
 200               	.LVL18:
  58:uart.c        ****     itoa(s_msg->rtr,buffer, 16);
 201               		.loc 1 58 0
 202 0070 8C81      		ldd r24,Y+4
 203               	.LBB23:
 204               	.LBB24:
 205               		.loc 2 428 0
 206 0072 40E1      		ldi r20,lo8(16)
 207 0074 60E0      		ldi r22,lo8(buffer)
 208 0076 70E0      		ldi r23,hi8(buffer)
 209 0078 90E0      		ldi r25,0
 210 007a 00D0      		rcall __itoa_ncheck
 211               	.LVL19:
 212               	.LBE24:
 213               	.LBE23:
  59:uart.c        ****     uart_puts(buffer);
 214               		.loc 1 59 0
 215 007c 80E0      		ldi r24,lo8(buffer)
 216 007e 90E0      		ldi r25,hi8(buffer)
 217 0080 00D0      		rcall uart_puts
 218               	.LVL20:
 219 0082 7E01      		movw r14,r28
 220 0084 86E0      		ldi r24,6
 221 0086 E80E      		add r14,r24
 222 0088 F11C      		adc r15,__zero_reg__
 223               	.LBB25:
  60:uart.c        **** 
  61:uart.c        ****     for(int i = 0; i < s_msg->length; i++)
 224               		.loc 1 61 0
 225 008a 00E0      		ldi r16,0
 226 008c 10E0      		ldi r17,0
 227               	.LVL21:
 228               	.L12:
 229               		.loc 1 61 0 is_stmt 0 discriminator 1
 230 008e 8D81      		ldd r24,Y+5
 231 0090 90E0      		ldi r25,0
 232 0092 0817      		cp r16,r24
 233 0094 1907      		cpc r17,r25
 234 0096 04F4      		brge .L14
  62:uart.c        ****     {
  63:uart.c        ****         uart_puts("\n\rData: 0x");
 235               		.loc 1 63 0 is_stmt 1 discriminator 3
 236 0098 80E0      		ldi r24,lo8(.LC3)
 237 009a 90E0      		ldi r25,hi8(.LC3)
 238 009c 00D0      		rcall uart_puts
 239               	.LVL22:
  64:uart.c        ****         itoa(s_msg->data[i],buffer, 16);
 240               		.loc 1 64 0 discriminator 3
 241 009e F701      		movw r30,r14
 242 00a0 8191      		ld r24,Z+
 243 00a2 7F01      		movw r14,r30
 244               	.LVL23:
 245               	.LBB26:
 246               	.LBB27:
 247               		.loc 2 428 0 discriminator 3
 248 00a4 40E1      		ldi r20,lo8(16)
 249 00a6 60E0      		ldi r22,lo8(buffer)
 250 00a8 70E0      		ldi r23,hi8(buffer)
 251 00aa 90E0      		ldi r25,0
 252 00ac 00D0      		rcall __itoa_ncheck
 253               	.LVL24:
 254               	.LBE27:
 255               	.LBE26:
  65:uart.c        ****         uart_puts(buffer);
 256               		.loc 1 65 0 discriminator 3
 257 00ae 80E0      		ldi r24,lo8(buffer)
 258 00b0 90E0      		ldi r25,hi8(buffer)
 259 00b2 00D0      		rcall uart_puts
 260               	.LVL25:
  61:uart.c        ****     {
 261               		.loc 1 61 0 discriminator 3
 262 00b4 0F5F      		subi r16,-1
 263 00b6 1F4F      		sbci r17,-1
 264               	.LVL26:
 265 00b8 00C0      		rjmp .L12
 266               	.LVL27:
 267               	.L14:
 268               	.LBE25:
  66:uart.c        ****     }
  67:uart.c        ****     
  68:uart.c        ****     uart_puts("\n\r");
 269               		.loc 1 68 0
 270 00ba 80E0      		ldi r24,lo8(.LC4)
 271 00bc 90E0      		ldi r25,hi8(.LC4)
 272               	/* epilogue start */
  69:uart.c        ****     return;
  70:uart.c        **** }
 273               		.loc 1 70 0
 274 00be DF91      		pop r29
 275 00c0 CF91      		pop r28
 276               	.LVL28:
 277 00c2 1F91      		pop r17
 278 00c4 0F91      		pop r16
 279               	.LVL29:
 280 00c6 FF90      		pop r15
 281 00c8 EF90      		pop r14
  68:uart.c        ****     return;
 282               		.loc 1 68 0
 283 00ca 00C0      		rjmp uart_puts
 284               	.LVL30:
 285               		.cfi_endproc
 286               	.LFE7:
 288               		.local	buffer
 289               		.comm	buffer,9,1
 290               	.Letext0:
 291               		.file 3 "/usr/avr/include/stdint.h"
 292               		.file 4 "mcp2515.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 uart.c
     /tmp/ccQBUrsL.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccQBUrsL.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccQBUrsL.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccQBUrsL.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccQBUrsL.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccQBUrsL.s:12     .text:0000000000000000 uart_init
     /tmp/ccQBUrsL.s:39     .text:000000000000000e uart_putc
     /tmp/ccQBUrsL.s:60     .text:0000000000000016 uart_puts
     /tmp/ccQBUrsL.s:115    .text:000000000000002c uart_can_msg
                             .bss:0000000000000000 buffer

UNDEFINED SYMBOLS
__itoa_ncheck
__do_copy_data
__do_clear_bss
