   1               		.file	"mcp2515.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	mcp_write_reg
  12               	mcp_write_reg:
  13               	.LFB6:
  14               		.file 1 "mcp2515.c"
   1:mcp2515.c     **** /*
   2:mcp2515.c     ****  * Author: Felix Schulze
   3:mcp2515.c     ****  * Date:   21/02/2015
   4:mcp2515.c     ****  *
   5:mcp2515.c     ****  *
   6:mcp2515.c     ****  */
   7:mcp2515.c     **** 
   8:mcp2515.c     **** #include <util/delay.h>
   9:mcp2515.c     **** #include "spi.h"
  10:mcp2515.c     **** #include "uart.h"
  11:mcp2515.c     **** #include "mcp2515.h"
  12:mcp2515.c     **** 
  13:mcp2515.c     **** void mcp_write_reg(uint8_t addr, uint8_t data)
  14:mcp2515.c     **** {
  15               		.loc 1 14 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 1F93      		push r17
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 17, -2
  22 0002 CF93      		push r28
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 28, -3
  26 0004 DF93      		push r29
  27               	.LCFI2:
  28               		.cfi_def_cfa_offset 5
  29               		.cfi_offset 29, -4
  30 0006 1F92      		push __zero_reg__
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 6
  33 0008 CDB7      		in r28,__SP_L__
  34 000a DEB7      		in r29,__SP_H__
  35               	.LCFI4:
  36               		.cfi_def_cfa_register 28
  37               	/* prologue: function */
  38               	/* frame size = 1 */
  39               	/* stack size = 4 */
  40               	.L__stack_usage = 4
  41 000c 182F      		mov r17,r24
  15:mcp2515.c     **** 	PORT_CS &= ~(1<<P_CS);
  42               		.loc 1 15 0
  43 000e C298      		cbi 0x18,2
  16:mcp2515.c     **** 
  17:mcp2515.c     **** 	spi_trans(SPI_WRITE);
  44               		.loc 1 17 0
  45 0010 82E0      		ldi r24,lo8(2)
  46               	.LVL1:
  47 0012 6983      		std Y+1,r22
  48 0014 00D0      		rcall spi_trans
  49               	.LVL2:
  18:mcp2515.c     **** 	spi_trans(addr);
  50               		.loc 1 18 0
  51 0016 812F      		mov r24,r17
  52 0018 00D0      		rcall spi_trans
  53               	.LVL3:
  19:mcp2515.c     **** 	spi_trans(data);
  54               		.loc 1 19 0
  55 001a 6981      		ldd r22,Y+1
  56 001c 862F      		mov r24,r22
  57 001e 00D0      		rcall spi_trans
  58               	.LVL4:
  20:mcp2515.c     **** 
  21:mcp2515.c     **** 	PORT_CS |= (1<<P_CS);
  59               		.loc 1 21 0
  60 0020 C29A      		sbi 0x18,2
  61               	/* epilogue start */
  22:mcp2515.c     **** 	
  23:mcp2515.c     **** 	return;
  24:mcp2515.c     **** }
  62               		.loc 1 24 0
  63 0022 0F90      		pop __tmp_reg__
  64 0024 DF91      		pop r29
  65 0026 CF91      		pop r28
  66 0028 1F91      		pop r17
  67               	.LVL5:
  68 002a 0895      		ret
  69               		.cfi_endproc
  70               	.LFE6:
  72               	.global	mcp_read_reg
  74               	mcp_read_reg:
  75               	.LFB7:
  25:mcp2515.c     **** 
  26:mcp2515.c     **** uint8_t mcp_read_reg(uint8_t addr)
  27:mcp2515.c     **** {
  76               		.loc 1 27 0
  77               		.cfi_startproc
  78               	.LVL6:
  79 002c CF93      		push r28
  80               	.LCFI5:
  81               		.cfi_def_cfa_offset 3
  82               		.cfi_offset 28, -2
  83               	/* prologue: function */
  84               	/* frame size = 0 */
  85               	/* stack size = 1 */
  86               	.L__stack_usage = 1
  87 002e C82F      		mov r28,r24
  28:mcp2515.c     **** 	uint8_t data;
  29:mcp2515.c     **** 
  30:mcp2515.c     **** 	PORT_CS &= ~(1<<P_CS);
  88               		.loc 1 30 0
  89 0030 C298      		cbi 0x18,2
  31:mcp2515.c     **** 
  32:mcp2515.c     **** 	spi_trans(SPI_READ);
  90               		.loc 1 32 0
  91 0032 83E0      		ldi r24,lo8(3)
  92               	.LVL7:
  93 0034 00D0      		rcall spi_trans
  94               	.LVL8:
  33:mcp2515.c     **** 	spi_trans(addr);
  95               		.loc 1 33 0
  96 0036 8C2F      		mov r24,r28
  97 0038 00D0      		rcall spi_trans
  98               	.LVL9:
  34:mcp2515.c     **** 	data = spi_trans(0xff);
  99               		.loc 1 34 0
 100 003a 8FEF      		ldi r24,lo8(-1)
 101 003c 00D0      		rcall spi_trans
 102               	.LVL10:
  35:mcp2515.c     **** 
  36:mcp2515.c     **** 	PORT_CS |= (1<<P_CS);
 103               		.loc 1 36 0
 104 003e C29A      		sbi 0x18,2
 105               	/* epilogue start */
  37:mcp2515.c     **** 	
  38:mcp2515.c     **** 	return data;
  39:mcp2515.c     **** }
 106               		.loc 1 39 0
 107 0040 CF91      		pop r28
 108               	.LVL11:
 109 0042 0895      		ret
 110               		.cfi_endproc
 111               	.LFE7:
 113               	.global	mcp_bit_mod
 115               	mcp_bit_mod:
 116               	.LFB8:
  40:mcp2515.c     **** 
  41:mcp2515.c     **** void mcp_bit_mod(uint8_t addr, uint8_t mask, uint8_t data)
  42:mcp2515.c     **** {
 117               		.loc 1 42 0
 118               		.cfi_startproc
 119               	.LVL12:
 120 0044 1F93      		push r17
 121               	.LCFI6:
 122               		.cfi_def_cfa_offset 3
 123               		.cfi_offset 17, -2
 124 0046 CF93      		push r28
 125               	.LCFI7:
 126               		.cfi_def_cfa_offset 4
 127               		.cfi_offset 28, -3
 128 0048 DF93      		push r29
 129               	.LCFI8:
 130               		.cfi_def_cfa_offset 5
 131               		.cfi_offset 29, -4
 132 004a 00D0      		rcall .
 133               	.LCFI9:
 134               		.cfi_def_cfa_offset 7
 135 004c CDB7      		in r28,__SP_L__
 136 004e DEB7      		in r29,__SP_H__
 137               	.LCFI10:
 138               		.cfi_def_cfa_register 28
 139               	/* prologue: function */
 140               	/* frame size = 2 */
 141               	/* stack size = 5 */
 142               	.L__stack_usage = 5
 143 0050 182F      		mov r17,r24
  43:mcp2515.c     **** 	PORT_CS &= ~(1<<P_CS);
 144               		.loc 1 43 0
 145 0052 C298      		cbi 0x18,2
  44:mcp2515.c     **** 
  45:mcp2515.c     **** 	spi_trans(SPI_BIT_MOD);
 146               		.loc 1 45 0
 147 0054 85E0      		ldi r24,lo8(5)
 148               	.LVL13:
 149 0056 4A83      		std Y+2,r20
 150 0058 6983      		std Y+1,r22
 151 005a 00D0      		rcall spi_trans
 152               	.LVL14:
  46:mcp2515.c     **** 	spi_trans(addr);
 153               		.loc 1 46 0
 154 005c 812F      		mov r24,r17
 155 005e 00D0      		rcall spi_trans
 156               	.LVL15:
  47:mcp2515.c     **** 	spi_trans(mask);
 157               		.loc 1 47 0
 158 0060 6981      		ldd r22,Y+1
 159 0062 862F      		mov r24,r22
 160 0064 00D0      		rcall spi_trans
 161               	.LVL16:
  48:mcp2515.c     **** 	spi_trans(data);
 162               		.loc 1 48 0
 163 0066 4A81      		ldd r20,Y+2
 164 0068 842F      		mov r24,r20
 165 006a 00D0      		rcall spi_trans
 166               	.LVL17:
  49:mcp2515.c     **** 
  50:mcp2515.c     **** 	PORT_CS |= (1<<P_CS);
 167               		.loc 1 50 0
 168 006c C29A      		sbi 0x18,2
 169               	/* epilogue start */
  51:mcp2515.c     **** 	
  52:mcp2515.c     **** 	return;
  53:mcp2515.c     **** }
 170               		.loc 1 53 0
 171 006e 0F90      		pop __tmp_reg__
 172 0070 0F90      		pop __tmp_reg__
 173 0072 DF91      		pop r29
 174 0074 CF91      		pop r28
 175 0076 1F91      		pop r17
 176               	.LVL18:
 177 0078 0895      		ret
 178               		.cfi_endproc
 179               	.LFE8:
 181               	.global	mcp_init
 183               	mcp_init:
 184               	.LFB9:
  54:mcp2515.c     **** 
  55:mcp2515.c     **** void mcp_init(void)
  56:mcp2515.c     **** {
 185               		.loc 1 56 0
 186               		.cfi_startproc
 187               	/* prologue: function */
 188               	/* frame size = 0 */
 189               	/* stack size = 0 */
 190               	.L__stack_usage = 0
  57:mcp2515.c     **** 
  58:mcp2515.c     **** 	spi_init();
 191               		.loc 1 58 0
 192 007a 00D0      		rcall spi_init
 193               	.LVL19:
  59:mcp2515.c     **** 
  60:mcp2515.c     **** 	PORT_CS &= ~(1<<P_CS);
 194               		.loc 1 60 0
 195 007c C298      		cbi 0x18,2
  61:mcp2515.c     **** 	spi_trans(SPI_RESET);
 196               		.loc 1 61 0
 197 007e 80EC      		ldi r24,lo8(-64)
 198 0080 00D0      		rcall spi_trans
 199               	.LVL20:
 200               	.LBB6:
 201               	.LBB7:
 202               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2385 2013-05-03 13:14:20Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/avr/include/util/delay.h **** #endif
  41:/usr/avr/include/util/delay.h **** 
  42:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/avr/include/util/delay.h **** #include <math.h>
  45:/usr/avr/include/util/delay.h **** 
  46:/usr/avr/include/util/delay.h **** /** \file */
  47:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/avr/include/util/delay.h ****     \code
  49:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/avr/include/util/delay.h ****     \endcode
  53:/usr/avr/include/util/delay.h **** 
  54:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/avr/include/util/delay.h ****     used.
  58:/usr/avr/include/util/delay.h **** 
  59:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/avr/include/util/delay.h **** 
  68:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/avr/include/util/delay.h **** 
  77:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/avr/include/util/delay.h **** 
  81:/usr/avr/include/util/delay.h **** */
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/avr/include/util/delay.h **** #endif
  87:/usr/avr/include/util/delay.h **** 
  88:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/avr/include/util/delay.h **** #endif
  93:/usr/avr/include/util/delay.h **** 
  94:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/avr/include/util/delay.h **** #endif
  97:/usr/avr/include/util/delay.h **** 
  98:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/avr/include/util/delay.h **** #endif
 103:/usr/avr/include/util/delay.h **** 
 104:/usr/avr/include/util/delay.h **** /**
 105:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/avr/include/util/delay.h **** 
 107:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/avr/include/util/delay.h **** 
 109:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/avr/include/util/delay.h **** 
 112:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/avr/include/util/delay.h **** 
 114:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/avr/include/util/delay.h **** 
 120:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/avr/include/util/delay.h **** 
 125:/usr/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/avr/include/util/delay.h **** 
 132:/usr/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/avr/include/util/delay.h **** 
 140:/usr/avr/include/util/delay.h ****  */
 141:/usr/avr/include/util/delay.h **** void
 142:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/avr/include/util/delay.h **** {
 144:/usr/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/avr/include/util/delay.h **** 
 155:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/avr/include/util/delay.h **** 
 158:/usr/avr/include/util/delay.h **** 	#else
 159:/usr/avr/include/util/delay.h **** 		//round up by default
 160:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/avr/include/util/delay.h **** 	#endif
 162:/usr/avr/include/util/delay.h **** 
 163:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 203               		.loc 2 163 0
 204 0082 83E3      		ldi r24,lo8(1843)
 205 0084 97E0      		ldi r25,hi8(1843)
 206 0086 0197      		1: sbiw r24,1
 207 0088 01F4      		brne 1b
 208               	.LBE7:
 209               	.LBE6:
  62:mcp2515.c     **** 	_delay_ms(1);
  63:mcp2515.c     **** 	PORT_CS |= (1<<P_CS);
 210               		.loc 1 63 0
 211 008a C29A      		sbi 0x18,2
 212               	.LVL21:
 213               	.LBB8:
 214               	.LBB9:
 215               		.loc 2 163 0
 216 008c 8FEF      		ldi r24,lo8(18431)
 217 008e 97E4      		ldi r25,hi8(18431)
 218 0090 0197      		1: sbiw r24,1
 219 0092 01F4      		brne 1b
 220 0094 00C0      		rjmp .
 221 0096 0000      		nop
 222               	.LBE9:
 223               	.LBE8:
  64:mcp2515.c     **** 	_delay_ms(10);
  65:mcp2515.c     **** 
  66:mcp2515.c     **** 	// set can clock rate
  67:mcp2515.c     **** 	mcp_write_reg(CNF1, R_CNF1);
 224               		.loc 1 67 0
 225 0098 67E0      		ldi r22,lo8(7)
 226 009a 8AE2      		ldi r24,lo8(42)
 227 009c 00D0      		rcall mcp_write_reg
 228               	.LVL22:
  68:mcp2515.c     **** 	mcp_write_reg(CNF2, R_CNF2);
 229               		.loc 1 68 0
 230 009e 60E9      		ldi r22,lo8(-112)
 231 00a0 89E2      		ldi r24,lo8(41)
 232 00a2 00D0      		rcall mcp_write_reg
 233               	.LVL23:
  69:mcp2515.c     **** 	mcp_write_reg(CNF3, R_CNF3);
 234               		.loc 1 69 0
 235 00a4 62E0      		ldi r22,lo8(2)
 236 00a6 88E2      		ldi r24,lo8(40)
 237 00a8 00D0      		rcall mcp_write_reg
 238               	.LVL24:
  70:mcp2515.c     **** 
  71:mcp2515.c     **** 	mcp_write_reg(CANINTE, (1<<RX1IE)|(1<<RX0IE));
 239               		.loc 1 71 0
 240 00aa 63E0      		ldi r22,lo8(3)
 241 00ac 8BE2      		ldi r24,lo8(43)
 242 00ae 00D0      		rcall mcp_write_reg
 243               	.LVL25:
  72:mcp2515.c     **** 
  73:mcp2515.c     **** 	// clear msg masks
  74:mcp2515.c     **** 	mcp_write_reg( RXB0CTRL, (1<<RXM1)|(1<<RXM0) );
 244               		.loc 1 74 0
 245 00b0 60E6      		ldi r22,lo8(96)
 246 00b2 80E6      		ldi r24,lo8(96)
 247 00b4 00D0      		rcall mcp_write_reg
 248               	.LVL26:
  75:mcp2515.c     **** 	mcp_write_reg( RXB1CTRL, (1<<RXM1)|(1<<RXM0) );
 249               		.loc 1 75 0
 250 00b6 60E6      		ldi r22,lo8(96)
 251 00b8 80E7      		ldi r24,lo8(112)
 252 00ba 00D0      		rcall mcp_write_reg
 253               	.LVL27:
  76:mcp2515.c     **** 
  77:mcp2515.c     **** 	mcp_write_reg( RXM0SIDH, 0 );
 254               		.loc 1 77 0
 255 00bc 60E0      		ldi r22,0
 256 00be 80E5      		ldi r24,lo8(80)
 257 00c0 00D0      		rcall mcp_write_reg
 258               	.LVL28:
  78:mcp2515.c     **** 	mcp_write_reg( RXM0SIDL, 0 );
 259               		.loc 1 78 0
 260 00c2 60E0      		ldi r22,0
 261 00c4 81E2      		ldi r24,lo8(33)
 262 00c6 00D0      		rcall mcp_write_reg
 263               	.LVL29:
  79:mcp2515.c     **** 	mcp_write_reg( RXM0EID8, 0 );
 264               		.loc 1 79 0
 265 00c8 60E0      		ldi r22,0
 266 00ca 82E2      		ldi r24,lo8(34)
 267 00cc 00D0      		rcall mcp_write_reg
 268               	.LVL30:
  80:mcp2515.c     **** 	mcp_write_reg( RXM0EID0, 0 );
 269               		.loc 1 80 0
 270 00ce 60E0      		ldi r22,0
 271 00d0 83E2      		ldi r24,lo8(35)
 272 00d2 00D0      		rcall mcp_write_reg
 273               	.LVL31:
  81:mcp2515.c     **** 
  82:mcp2515.c     **** 	mcp_write_reg( RXM1SIDH, 0 );
 274               		.loc 1 82 0
 275 00d4 60E0      		ldi r22,0
 276 00d6 84E2      		ldi r24,lo8(36)
 277 00d8 00D0      		rcall mcp_write_reg
 278               	.LVL32:
  83:mcp2515.c     **** 	mcp_write_reg( RXM1SIDL, 0 );
 279               		.loc 1 83 0
 280 00da 60E0      		ldi r22,0
 281 00dc 85E2      		ldi r24,lo8(37)
 282 00de 00D0      		rcall mcp_write_reg
 283               	.LVL33:
  84:mcp2515.c     **** 	mcp_write_reg( RXM1EID8, 0 );
 284               		.loc 1 84 0
 285 00e0 60E0      		ldi r22,0
 286 00e2 86E2      		ldi r24,lo8(38)
 287 00e4 00D0      		rcall mcp_write_reg
 288               	.LVL34:
  85:mcp2515.c     **** 	mcp_write_reg( RXM1EID0, 0 );
 289               		.loc 1 85 0
 290 00e6 60E0      		ldi r22,0
 291 00e8 87E2      		ldi r24,lo8(39)
 292 00ea 00D0      		rcall mcp_write_reg
 293               	.LVL35:
  86:mcp2515.c     **** 
  87:mcp2515.c     **** 	// enable normal mode
  88:mcp2515.c     ****    	mcp_bit_mod( CANCTRL, 0xE0, 0);
 294               		.loc 1 88 0
 295 00ec 40E0      		ldi r20,0
 296 00ee 60EE      		ldi r22,lo8(-32)
 297 00f0 8FE0      		ldi r24,lo8(15)
 298 00f2 00C0      		rjmp mcp_bit_mod
 299               	.LVL36:
 300               		.cfi_endproc
 301               	.LFE9:
 303               		.section	.rodata.str1.1,"aMS",@progbits,1
 304               	.LC0:
 305 0000 0A00      		.string	"\n"
 306               		.text
 307               	.global	can_send_msg
 309               	can_send_msg:
 310               	.LFB10:
  89:mcp2515.c     **** 
  90:mcp2515.c     **** 	// for debugging enable loopback mode
  91:mcp2515.c     **** 	//mcp_bit_mod(CANCTRL, 0xE0, 0x40);
  92:mcp2515.c     **** 	return;
  93:mcp2515.c     **** }
  94:mcp2515.c     **** 
  95:mcp2515.c     **** 
  96:mcp2515.c     **** uint8_t can_send_msg(Canmsg *s_msg)
  97:mcp2515.c     **** {
 311               		.loc 1 97 0
 312               		.cfi_startproc
 313               	.LVL37:
 314 00f4 EF92      		push r14
 315               	.LCFI11:
 316               		.cfi_def_cfa_offset 3
 317               		.cfi_offset 14, -2
 318 00f6 FF92      		push r15
 319               	.LCFI12:
 320               		.cfi_def_cfa_offset 4
 321               		.cfi_offset 15, -3
 322 00f8 0F93      		push r16
 323               	.LCFI13:
 324               		.cfi_def_cfa_offset 5
 325               		.cfi_offset 16, -4
 326 00fa 1F93      		push r17
 327               	.LCFI14:
 328               		.cfi_def_cfa_offset 6
 329               		.cfi_offset 17, -5
 330 00fc CF93      		push r28
 331               	.LCFI15:
 332               		.cfi_def_cfa_offset 7
 333               		.cfi_offset 28, -6
 334 00fe DF93      		push r29
 335               	.LCFI16:
 336               		.cfi_def_cfa_offset 8
 337               		.cfi_offset 29, -7
 338 0100 CDB7      		in r28,__SP_L__
 339 0102 DEB7      		in r29,__SP_H__
 340               	.LCFI17:
 341               		.cfi_def_cfa_register 28
 342 0104 2A97      		sbiw r28,10
 343               	.LCFI18:
 344               		.cfi_def_cfa_offset 18
 345 0106 0FB6      		in __tmp_reg__,__SREG__
 346 0108 F894      		cli
 347 010a DEBF      		out __SP_H__,r29
 348 010c 0FBE      		out __SREG__,__tmp_reg__
 349 010e CDBF      		out __SP_L__,r28
 350               	/* prologue: function */
 351               	/* frame size = 10 */
 352               	/* stack size = 16 */
 353               	.L__stack_usage = 16
  98:mcp2515.c     **** 	int i;
  99:mcp2515.c     **** 	char buffer[10];
 100:mcp2515.c     **** 	uint8_t addr;
 101:mcp2515.c     **** 
 102:mcp2515.c     **** 	if(s_msg->length > 8)
 354               		.loc 1 102 0
 355 0110 FC01      		movw r30,r24
 356 0112 2581      		ldd r18,Z+5
 357 0114 2930      		cpi r18,lo8(9)
 358 0116 00F0      		brlo .+2
 359 0118 00C0      		rjmp .L14
 360 011a 8C01      		movw r16,r24
 103:mcp2515.c     **** 		return 2;
 104:mcp2515.c     **** 
 105:mcp2515.c     **** 	// search for free tx buffer
 106:mcp2515.c     **** 	PORT_CS &= ~(1<<P_CS);
 361               		.loc 1 106 0
 362 011c C298      		cbi 0x18,2
 107:mcp2515.c     ****    	spi_trans(SPI_READ_STAT);
 363               		.loc 1 107 0
 364 011e 80EA      		ldi r24,lo8(-96)
 365               	.LVL38:
 366 0120 00D0      		rcall spi_trans
 367               	.LVL39:
 108:mcp2515.c     ****    	addr = spi_trans(0xff);
 368               		.loc 1 108 0
 369 0122 8FEF      		ldi r24,lo8(-1)
 370 0124 00D0      		rcall spi_trans
 371               	.LVL40:
 109:mcp2515.c     ****    	PORT_CS |= (1<<P_CS);
 372               		.loc 1 109 0
 373 0126 C29A      		sbi 0x18,2
 110:mcp2515.c     **** 
 111:mcp2515.c     ****    	if(!(addr & (1<<TXB0CNTRL_TXREQ)))
 374               		.loc 1 111 0
 375 0128 82FF      		sbrs r24,2
 376 012a 00C0      		rjmp .L15
 112:mcp2515.c     ****    		addr = 0;
 113:mcp2515.c     ****    	else if (!(addr & (1<<TXB1CNTRL_TXREQ)))
 377               		.loc 1 113 0
 378 012c 84FF      		sbrs r24,4
 379 012e 00C0      		rjmp .L16
 114:mcp2515.c     ****    		addr = 0x02;
 115:mcp2515.c     ****    	else if (!(addr & (1<<TXB2CNTRL_TXREQ)))
 380               		.loc 1 115 0
 381 0130 86FD      		sbrc r24,6
 382 0132 00C0      		rjmp .L17
 116:mcp2515.c     ****    		addr = 0x04;
 383               		.loc 1 116 0
 384 0134 54E0      		ldi r21,lo8(4)
 385 0136 F52E      		mov r15,r21
 386 0138 00C0      		rjmp .L7
 387               	.L15:
 112:mcp2515.c     ****    		addr = 0;
 388               		.loc 1 112 0
 389 013a F12C      		mov r15,__zero_reg__
 390 013c 00C0      		rjmp .L7
 391               	.L16:
 114:mcp2515.c     ****    		addr = 0x02;
 392               		.loc 1 114 0
 393 013e 42E0      		ldi r20,lo8(2)
 394 0140 F42E      		mov r15,r20
 395               	.L7:
 396               	.LVL41:
 117:mcp2515.c     ****    	else
 118:mcp2515.c     ****    		//no free tx buffer found
 119:mcp2515.c     ****    		return 1;
 120:mcp2515.c     **** 
 121:mcp2515.c     **** 
 122:mcp2515.c     **** 	PORT_CS &= ~(1<<P_CS);
 397               		.loc 1 122 0
 398 0142 C298      		cbi 0x18,2
 123:mcp2515.c     **** 	spi_trans(SPI_LOAD_TX_BUF  | addr);
 399               		.loc 1 123 0
 400 0144 8F2D      		mov r24,r15
 401 0146 8064      		ori r24,lo8(64)
 402 0148 00D0      		rcall spi_trans
 403               	.LVL42:
 124:mcp2515.c     **** 	
 125:mcp2515.c     ****    
 126:mcp2515.c     ****   	/*spi_trans((uint8_t) (s_msg->id>>3));
 127:mcp2515.c     ****    	spi_trans((uint8_t) (s_msg->id<<5)  | (1<<EXIDE) | (uint8_t) ((s_msg->id>>27) & 0x03));
 128:mcp2515.c     **** 
 129:mcp2515.c     ****    	// jump of register for ext id
 130:mcp2515.c     ****  	spi_trans((uint8_t) (s_msg->id>>19));
 131:mcp2515.c     ****  	spi_trans((uint8_t) (s_msg->id>>11));*/
 132:mcp2515.c     **** 
 133:mcp2515.c     ****  	spi_trans((uint8_t) (s_msg->id>>21));
 404               		.loc 1 133 0
 405 014a F801      		movw r30,r16
 406 014c 8081      		ld r24,Z
 407 014e 9181      		ldd r25,Z+1
 408 0150 A281      		ldd r26,Z+2
 409 0152 B381      		ldd r27,Z+3
 410 0154 25E1      		ldi r18,21
 411               		1:
 412 0156 B695      		lsr r27
 413 0158 A795      		ror r26
 414 015a 9795      		ror r25
 415 015c 8795      		ror r24
 416 015e 2A95      		dec r18
 417 0160 01F4      		brne 1b
 418 0162 00D0      		rcall spi_trans
 419               	.LVL43:
 134:mcp2515.c     ****    	spi_trans((uint8_t) ((s_msg->id>>13) & 0xE0)  | (1<<EXIDE) | (uint8_t) ((s_msg->id>>16) & 0x03)
 420               		.loc 1 134 0
 421 0164 F801      		movw r30,r16
 422 0166 4081      		ld r20,Z
 423 0168 5181      		ldd r21,Z+1
 424 016a 6281      		ldd r22,Z+2
 425 016c 7381      		ldd r23,Z+3
 426 016e DB01      		movw r26,r22
 427 0170 CA01      		movw r24,r20
 428 0172 3DE0      		ldi r19,13
 429               		1:
 430 0174 B695      		lsr r27
 431 0176 A795      		ror r26
 432 0178 9795      		ror r25
 433 017a 8795      		ror r24
 434 017c 3A95      		dec r19
 435 017e 01F4      		brne 1b
 436 0180 807E      		andi r24,lo8(-32)
 437 0182 962F      		mov r25,r22
 438 0184 9370      		andi r25,lo8(3)
 439 0186 892B      		or r24,r25
 440 0188 8860      		ori r24,lo8(8)
 441 018a 00D0      		rcall spi_trans
 442               	.LVL44:
 135:mcp2515.c     **** 
 136:mcp2515.c     ****    	// jump of register for ext id
 137:mcp2515.c     ****  	spi_trans((uint8_t) (s_msg->id>>8));
 443               		.loc 1 137 0
 444 018c F801      		movw r30,r16
 445 018e 8181      		ldd r24,Z+1
 446 0190 00D0      		rcall spi_trans
 447               	.LVL45:
 138:mcp2515.c     ****  	spi_trans((uint8_t) s_msg->id);
 448               		.loc 1 138 0
 449 0192 F801      		movw r30,r16
 450 0194 8081      		ld r24,Z
 451 0196 00D0      		rcall spi_trans
 452               	.LVL46:
 139:mcp2515.c     **** 
 140:mcp2515.c     ****    	// if request ?
 141:mcp2515.c     ****    	if(s_msg->rtr)
 453               		.loc 1 141 0
 454 0198 F801      		movw r30,r16
 455 019a 8481      		ldd r24,Z+4
 456 019c 8823      		tst r24
 457 019e 01F0      		breq .L8
 142:mcp2515.c     ****    		spi_trans((1<<RTR) | s_msg->length);
 458               		.loc 1 142 0
 459 01a0 8581      		ldd r24,Z+5
 460 01a2 8068      		ori r24,lo8(-128)
 461 01a4 00D0      		rcall spi_trans
 462               	.LVL47:
 463 01a6 00C0      		rjmp .L9
 464               	.L8:
 143:mcp2515.c     ****    	else
 144:mcp2515.c     ****    	{
 145:mcp2515.c     ****    		spi_trans(s_msg->length);
 465               		.loc 1 145 0
 466 01a8 F801      		movw r30,r16
 467 01aa 8581      		ldd r24,Z+5
 468 01ac 00D0      		rcall spi_trans
 469               	.LVL48:
 470               	.LBB10:
 146:mcp2515.c     **** 
 147:mcp2515.c     ****    		for(uint8_t i = 0; i < s_msg->length; i++)
 471               		.loc 1 147 0
 472 01ae E12C      		mov r14,__zero_reg__
 473               	.LVL49:
 474               	.L10:
 475               		.loc 1 147 0 is_stmt 0 discriminator 1
 476 01b0 F801      		movw r30,r16
 477 01b2 8581      		ldd r24,Z+5
 478 01b4 E816      		cp r14,r24
 479 01b6 00F4      		brsh .L9
 148:mcp2515.c     ****    			spi_trans(s_msg->data[i]);
 480               		.loc 1 148 0 is_stmt 1 discriminator 3
 481 01b8 F801      		movw r30,r16
 482 01ba EE0D      		add r30,r14
 483 01bc F11D      		adc r31,__zero_reg__
 484 01be 8681      		ldd r24,Z+6
 485 01c0 00D0      		rcall spi_trans
 486               	.LVL50:
 147:mcp2515.c     ****    			spi_trans(s_msg->data[i]);
 487               		.loc 1 147 0 discriminator 3
 488 01c2 E394      		inc r14
 489               	.LVL51:
 490 01c4 00C0      		rjmp .L10
 491               	.LVL52:
 492               	.L9:
 493               	.LBE10:
 149:mcp2515.c     ****    	}
 150:mcp2515.c     **** 
 151:mcp2515.c     ****    	PORT_CS |= (1<<P_CS);
 494               		.loc 1 151 0
 495 01c6 C29A      		sbi 0x18,2
 152:mcp2515.c     **** 
 153:mcp2515.c     ****    	// do nothing one cycle for toggle cs
 154:mcp2515.c     ****    	asm volatile ("nop");
 496               		.loc 1 154 0
 497               	/* #APP */
 498               	 ;  154 "mcp2515.c" 1
 499 01c8 0000      		nop
 500               	 ;  0 "" 2
 155:mcp2515.c     **** 
 156:mcp2515.c     **** 	i = mcp_read_reg(  TXB0SIDH);
 501               		.loc 1 156 0
 502               	/* #NOAPP */
 503 01ca 81E3      		ldi r24,lo8(49)
 504 01cc 00D0      		rcall mcp_read_reg
 505               	.LVL53:
 157:mcp2515.c     **** 	itoa(i, buffer,2);
 506               		.loc 1 157 0
 507 01ce 42E0      		ldi r20,lo8(2)
 508 01d0 50E0      		ldi r21,0
 509 01d2 BE01      		movw r22,r28
 510 01d4 6F5F      		subi r22,-1
 511 01d6 7F4F      		sbci r23,-1
 512 01d8 90E0      		ldi r25,0
 513 01da 00D0      		rcall itoa
 514               	.LVL54:
 158:mcp2515.c     **** 	uart_puts(buffer);
 515               		.loc 1 158 0
 516 01dc CE01      		movw r24,r28
 517 01de 0196      		adiw r24,1
 518 01e0 00D0      		rcall uart_puts
 519               	.LVL55:
 159:mcp2515.c     **** 	uart_puts("\n");
 520               		.loc 1 159 0
 521 01e2 80E0      		ldi r24,lo8(.LC0)
 522 01e4 90E0      		ldi r25,hi8(.LC0)
 523 01e6 00D0      		rcall uart_puts
 524               	.LVL56:
 160:mcp2515.c     **** 	i = mcp_read_reg( TXB0SIDL);
 525               		.loc 1 160 0
 526 01e8 82E3      		ldi r24,lo8(50)
 527 01ea 00D0      		rcall mcp_read_reg
 528               	.LVL57:
 161:mcp2515.c     **** 	itoa(i, buffer,2);
 529               		.loc 1 161 0
 530 01ec 42E0      		ldi r20,lo8(2)
 531 01ee 50E0      		ldi r21,0
 532 01f0 BE01      		movw r22,r28
 533 01f2 6F5F      		subi r22,-1
 534 01f4 7F4F      		sbci r23,-1
 535 01f6 90E0      		ldi r25,0
 536 01f8 00D0      		rcall itoa
 537               	.LVL58:
 162:mcp2515.c     **** 	uart_puts(buffer);
 538               		.loc 1 162 0
 539 01fa CE01      		movw r24,r28
 540 01fc 0196      		adiw r24,1
 541 01fe 00D0      		rcall uart_puts
 542               	.LVL59:
 163:mcp2515.c     **** 	uart_puts("\n");
 543               		.loc 1 163 0
 544 0200 80E0      		ldi r24,lo8(.LC0)
 545 0202 90E0      		ldi r25,hi8(.LC0)
 546 0204 00D0      		rcall uart_puts
 547               	.LVL60:
 164:mcp2515.c     **** 	i =mcp_read_reg( TXB0EID8);
 548               		.loc 1 164 0
 549 0206 83E3      		ldi r24,lo8(51)
 550 0208 00D0      		rcall mcp_read_reg
 551               	.LVL61:
 165:mcp2515.c     **** 	itoa(i, buffer,2);
 552               		.loc 1 165 0
 553 020a 42E0      		ldi r20,lo8(2)
 554 020c 50E0      		ldi r21,0
 555 020e BE01      		movw r22,r28
 556 0210 6F5F      		subi r22,-1
 557 0212 7F4F      		sbci r23,-1
 558 0214 90E0      		ldi r25,0
 559 0216 00D0      		rcall itoa
 560               	.LVL62:
 166:mcp2515.c     **** 	uart_puts(buffer);
 561               		.loc 1 166 0
 562 0218 CE01      		movw r24,r28
 563 021a 0196      		adiw r24,1
 564 021c 00D0      		rcall uart_puts
 565               	.LVL63:
 167:mcp2515.c     **** 	uart_puts("\n");
 566               		.loc 1 167 0
 567 021e 80E0      		ldi r24,lo8(.LC0)
 568 0220 90E0      		ldi r25,hi8(.LC0)
 569 0222 00D0      		rcall uart_puts
 570               	.LVL64:
 168:mcp2515.c     **** 	i = mcp_read_reg( TXB0EID0);
 571               		.loc 1 168 0
 572 0224 84E3      		ldi r24,lo8(52)
 573 0226 00D0      		rcall mcp_read_reg
 574               	.LVL65:
 169:mcp2515.c     **** 	itoa(i, buffer,2);
 575               		.loc 1 169 0
 576 0228 42E0      		ldi r20,lo8(2)
 577 022a 50E0      		ldi r21,0
 578 022c BE01      		movw r22,r28
 579 022e 6F5F      		subi r22,-1
 580 0230 7F4F      		sbci r23,-1
 581 0232 90E0      		ldi r25,0
 582 0234 00D0      		rcall itoa
 583               	.LVL66:
 170:mcp2515.c     **** 	uart_puts(buffer);
 584               		.loc 1 170 0
 585 0236 CE01      		movw r24,r28
 586 0238 0196      		adiw r24,1
 587 023a 00D0      		rcall uart_puts
 588               	.LVL67:
 171:mcp2515.c     **** 	uart_puts("\n");
 589               		.loc 1 171 0
 590 023c 80E0      		ldi r24,lo8(.LC0)
 591 023e 90E0      		ldi r25,hi8(.LC0)
 592 0240 00D0      		rcall uart_puts
 593               	.LVL68:
 172:mcp2515.c     **** 
 173:mcp2515.c     **** 
 174:mcp2515.c     **** 
 175:mcp2515.c     ****    	PORT_CS &= ~(1<<P_CS);
 594               		.loc 1 175 0
 595 0242 C298      		cbi 0x18,2
 176:mcp2515.c     **** 
 177:mcp2515.c     ****    	if(addr == 0)
 596               		.loc 1 177 0
 597 0244 F110      		cpse r15,__zero_reg__
 598 0246 00C0      		rjmp .L12
 178:mcp2515.c     ****    		spi_trans(SPI_RTS | 0x01);
 599               		.loc 1 178 0
 600 0248 81E8      		ldi r24,lo8(-127)
 601 024a 00C0      		rjmp .L18
 602               	.L12:
 179:mcp2515.c     ****    	else
 180:mcp2515.c     ****    		spi_trans(SPI_RTS | addr);
 603               		.loc 1 180 0
 604 024c 8F2D      		mov r24,r15
 605 024e 8068      		ori r24,lo8(-128)
 606               	.L18:
 607 0250 00D0      		rcall spi_trans
 608               	.LVL69:
 181:mcp2515.c     **** 
 182:mcp2515.c     ****    	PORT_CS |= (1<<P_CS);
 609               		.loc 1 182 0
 610 0252 C29A      		sbi 0x18,2
 183:mcp2515.c     **** 
 184:mcp2515.c     ****    	return 0;
 611               		.loc 1 184 0
 612 0254 80E0      		ldi r24,0
 613 0256 00C0      		rjmp .L6
 614               	.LVL70:
 615               	.L14:
 103:mcp2515.c     **** 
 616               		.loc 1 103 0
 617 0258 82E0      		ldi r24,lo8(2)
 618               	.LVL71:
 619 025a 00C0      		rjmp .L6
 620               	.LVL72:
 621               	.L17:
 119:mcp2515.c     **** 
 622               		.loc 1 119 0
 623 025c 81E0      		ldi r24,lo8(1)
 624               	.LVL73:
 625               	.L6:
 626               	/* epilogue start */
 185:mcp2515.c     **** }
 627               		.loc 1 185 0
 628 025e 2A96      		adiw r28,10
 629 0260 0FB6      		in __tmp_reg__,__SREG__
 630 0262 F894      		cli
 631 0264 DEBF      		out __SP_H__,r29
 632 0266 0FBE      		out __SREG__,__tmp_reg__
 633 0268 CDBF      		out __SP_L__,r28
 634 026a DF91      		pop r29
 635 026c CF91      		pop r28
 636 026e 1F91      		pop r17
 637 0270 0F91      		pop r16
 638 0272 FF90      		pop r15
 639 0274 EF90      		pop r14
 640 0276 0895      		ret
 641               		.cfi_endproc
 642               	.LFE10:
 644               	.global	mcp_read_rx_stat
 646               	mcp_read_rx_stat:
 647               	.LFB11:
 186:mcp2515.c     **** 
 187:mcp2515.c     **** uint8_t mcp_read_rx_stat(void)
 188:mcp2515.c     **** {
 648               		.loc 1 188 0
 649               		.cfi_startproc
 650               	/* prologue: function */
 651               	/* frame size = 0 */
 652               	/* stack size = 0 */
 653               	.L__stack_usage = 0
 189:mcp2515.c     **** 	uint8_t data;
 190:mcp2515.c     **** 	PORT_CS &= ~(1<<P_CS);
 654               		.loc 1 190 0
 655 0278 C298      		cbi 0x18,2
 191:mcp2515.c     **** 	spi_trans(SPI_RX_STAT);
 656               		.loc 1 191 0
 657 027a 80EB      		ldi r24,lo8(-80)
 658 027c 00D0      		rcall spi_trans
 659               	.LVL74:
 192:mcp2515.c     **** 	data = spi_trans(0xff);
 660               		.loc 1 192 0
 661 027e 8FEF      		ldi r24,lo8(-1)
 662 0280 00D0      		rcall spi_trans
 663               	.LVL75:
 193:mcp2515.c     **** 	PORT_CS |= (1<<P_CS);
 664               		.loc 1 193 0
 665 0282 C29A      		sbi 0x18,2
 194:mcp2515.c     **** 
 195:mcp2515.c     **** 	return data;
 196:mcp2515.c     **** }
 666               		.loc 1 196 0
 667 0284 0895      		ret
 668               		.cfi_endproc
 669               	.LFE11:
 671               	.global	can_get_msg
 673               	can_get_msg:
 674               	.LFB12:
 197:mcp2515.c     **** 
 198:mcp2515.c     **** uint8_t can_get_msg(Canmsg *s_msg)
 199:mcp2515.c     **** {
 675               		.loc 1 199 0
 676               		.cfi_startproc
 677               	.LVL76:
 678 0286 FF92      		push r15
 679               	.LCFI19:
 680               		.cfi_def_cfa_offset 3
 681               		.cfi_offset 15, -2
 682 0288 0F93      		push r16
 683               	.LCFI20:
 684               		.cfi_def_cfa_offset 4
 685               		.cfi_offset 16, -3
 686 028a 1F93      		push r17
 687               	.LCFI21:
 688               		.cfi_def_cfa_offset 5
 689               		.cfi_offset 17, -4
 690 028c CF93      		push r28
 691               	.LCFI22:
 692               		.cfi_def_cfa_offset 6
 693               		.cfi_offset 28, -5
 694 028e DF93      		push r29
 695               	.LCFI23:
 696               		.cfi_def_cfa_offset 7
 697               		.cfi_offset 29, -6
 698               	/* prologue: function */
 699               	/* frame size = 0 */
 700               	/* stack size = 5 */
 701               	.L__stack_usage = 5
 702 0290 EC01      		movw r28,r24
 200:mcp2515.c     **** 	uint8_t status = mcp_read_rx_stat();
 703               		.loc 1 200 0
 704 0292 00D0      		rcall mcp_read_rx_stat
 705               	.LVL77:
 706 0294 082F      		mov r16,r24
 707               	.LVL78:
 201:mcp2515.c     **** 
 202:mcp2515.c     **** 	// message in buffer0
 203:mcp2515.c     **** 	if(status & (1<<6)) 
 708               		.loc 1 203 0
 709 0296 182F      		mov r17,r24
 710 0298 1074      		andi r17,lo8(64)
 711 029a 86FF      		sbrs r24,6
 712 029c 00C0      		rjmp .L22
 204:mcp2515.c     **** 	{
 205:mcp2515.c     **** 		PORT_CS &= ~(1<<P_CS);
 713               		.loc 1 205 0
 714 029e C298      		cbi 0x18,2
 206:mcp2515.c     **** 		spi_trans(SPI_READ_RX_BUF);
 715               		.loc 1 206 0
 716 02a0 80E9      		ldi r24,lo8(-112)
 717 02a2 00C0      		rjmp .L31
 718               	.L22:
 207:mcp2515.c     **** 	}
 208:mcp2515.c     **** 	// message in buffer1
 209:mcp2515.c     **** 	else if(status & (1<<7))
 719               		.loc 1 209 0
 720 02a4 87FF      		sbrs r24,7
 721 02a6 00C0      		rjmp .L30
 210:mcp2515.c     **** 	{
 211:mcp2515.c     **** 		PORT_CS &= ~(1<<P_CS);
 722               		.loc 1 211 0
 723 02a8 C298      		cbi 0x18,2
 212:mcp2515.c     **** 		spi_trans(SPI_READ_RX_BUF | 0x04);
 724               		.loc 1 212 0
 725 02aa 84E9      		ldi r24,lo8(-108)
 726               	.L31:
 727 02ac 00D0      		rcall spi_trans
 728               	.LVL79:
 213:mcp2515.c     **** 	}
 214:mcp2515.c     **** 	// no message
 215:mcp2515.c     **** 	else
 216:mcp2515.c     **** 	{
 217:mcp2515.c     **** 		return 1;
 218:mcp2515.c     **** 	}
 219:mcp2515.c     **** 
 220:mcp2515.c     **** 	// read std id
 221:mcp2515.c     **** 	s_msg -> id = (uint16_t) spi_trans(0xff) << 3;
 729               		.loc 1 221 0
 730 02ae 8FEF      		ldi r24,lo8(-1)
 731 02b0 00D0      		rcall spi_trans
 732               	.LVL80:
 733 02b2 28E0      		ldi r18,lo8(8)
 734 02b4 829F      		mul r24,r18
 735 02b6 C001      		movw r24,r0
 736 02b8 1124      		clr __zero_reg__
 737 02ba A0E0      		ldi r26,0
 738 02bc B0E0      		ldi r27,0
 739 02be 8883      		st Y,r24
 740 02c0 9983      		std Y+1,r25
 741 02c2 AA83      		std Y+2,r26
 742 02c4 BB83      		std Y+3,r27
 222:mcp2515.c     **** 	s_msg -> id |= (uint16_t) spi_trans(0xff) >> 5;
 743               		.loc 1 222 0
 744 02c6 8FEF      		ldi r24,lo8(-1)
 745 02c8 00D0      		rcall spi_trans
 746               	.LVL81:
 747 02ca 282F      		mov r18,r24
 748 02cc 2295      		swap r18
 749 02ce 2695      		lsr r18
 750 02d0 2770      		andi r18,lo8(7)
 751 02d2 8881      		ld r24,Y
 752 02d4 9981      		ldd r25,Y+1
 753 02d6 AA81      		ldd r26,Y+2
 754 02d8 BB81      		ldd r27,Y+3
 755 02da 822B      		or r24,r18
 756 02dc 8883      		st Y,r24
 757 02de 9983      		std Y+1,r25
 758 02e0 AA83      		std Y+2,r26
 759 02e2 BB83      		std Y+3,r27
 223:mcp2515.c     **** 
 224:mcp2515.c     **** 	// jump over register for ext id
 225:mcp2515.c     **** 	spi_trans(0xff);
 760               		.loc 1 225 0
 761 02e4 8FEF      		ldi r24,lo8(-1)
 762 02e6 00D0      		rcall spi_trans
 763               	.LVL82:
 226:mcp2515.c     **** 	spi_trans(0xff);
 764               		.loc 1 226 0
 765 02e8 8FEF      		ldi r24,lo8(-1)
 766 02ea 00D0      		rcall spi_trans
 767               	.LVL83:
 227:mcp2515.c     **** 
 228:mcp2515.c     **** 	s_msg->length = spi_trans(0xff) & 0x0f;
 768               		.loc 1 228 0
 769 02ec 8FEF      		ldi r24,lo8(-1)
 770 02ee 00D0      		rcall spi_trans
 771               	.LVL84:
 772 02f0 8F70      		andi r24,lo8(15)
 773 02f2 8D83      		std Y+5,r24
 774               	.LVL85:
 775               	.LBB11:
 229:mcp2515.c     **** 
 230:mcp2515.c     **** 	for(uint8_t i =0 ; i < s_msg->length; i++)
 776               		.loc 1 230 0
 777 02f4 F12C      		mov r15,__zero_reg__
 778               	.LVL86:
 779               	.L25:
 780               		.loc 1 230 0 is_stmt 0 discriminator 1
 781 02f6 8D81      		ldd r24,Y+5
 782 02f8 F816      		cp r15,r24
 783 02fa 00F4      		brsh .L32
 231:mcp2515.c     **** 		s_msg->data[i] = spi_trans(0xff);
 784               		.loc 1 231 0 is_stmt 1 discriminator 3
 785 02fc 8FEF      		ldi r24,lo8(-1)
 786 02fe 00D0      		rcall spi_trans
 787               	.LVL87:
 788 0300 FE01      		movw r30,r28
 789 0302 EF0D      		add r30,r15
 790 0304 F11D      		adc r31,__zero_reg__
 791 0306 8683      		std Z+6,r24
 230:mcp2515.c     **** 		s_msg->data[i] = spi_trans(0xff);
 792               		.loc 1 230 0 discriminator 3
 793 0308 F394      		inc r15
 794               	.LVL88:
 795 030a 00C0      		rjmp .L25
 796               	.L32:
 797               	.LBE11:
 232:mcp2515.c     **** 
 233:mcp2515.c     **** 	PORT_CS |= (1<<P_CS);
 798               		.loc 1 233 0
 799 030c C29A      		sbi 0x18,2
 234:mcp2515.c     **** 
 235:mcp2515.c     **** 	// rtr msg ?
 236:mcp2515.c     **** 	if(status & (1<<3))
 800               		.loc 1 236 0
 801 030e 03FF      		sbrs r16,3
 802 0310 00C0      		rjmp .L27
 237:mcp2515.c     **** 		s_msg->rtr = 1;
 803               		.loc 1 237 0
 804 0312 81E0      		ldi r24,lo8(1)
 805 0314 8C83      		std Y+4,r24
 806 0316 00C0      		rjmp .L28
 807               	.L27:
 238:mcp2515.c     **** 	else
 239:mcp2515.c     **** 		s_msg->rtr = 0;
 808               		.loc 1 239 0
 809 0318 1C82      		std Y+4,__zero_reg__
 810               	.L28:
 240:mcp2515.c     **** 
 241:mcp2515.c     **** 	// clear interrupt flag for mcp2515
 242:mcp2515.c     **** 	if(status & (1<<6))
 243:mcp2515.c     **** 		mcp_bit_mod(CANINTF, (1<<RX0IF), 0);
 811               		.loc 1 243 0
 812 031a 40E0      		ldi r20,0
 242:mcp2515.c     **** 		mcp_bit_mod(CANINTF, (1<<RX0IF), 0);
 813               		.loc 1 242 0
 814 031c 1123      		tst r17
 815 031e 01F0      		breq .L29
 816               		.loc 1 243 0
 817 0320 61E0      		ldi r22,lo8(1)
 818 0322 8CE2      		ldi r24,lo8(44)
 819 0324 00D0      		rcall mcp_bit_mod
 820               	.LVL89:
 244:mcp2515.c     **** 	else
 245:mcp2515.c     **** 		mcp_bit_mod(CANINTF, (1<<RX1IF), 0);
 246:mcp2515.c     **** 
 247:mcp2515.c     **** 	return 0;
 821               		.loc 1 247 0
 822 0326 10E0      		ldi r17,0
 823 0328 00C0      		rjmp .L24
 824               	.L29:
 245:mcp2515.c     **** 
 825               		.loc 1 245 0
 826 032a 62E0      		ldi r22,lo8(2)
 827 032c 8CE2      		ldi r24,lo8(44)
 828 032e 00D0      		rcall mcp_bit_mod
 829               	.LVL90:
 830 0330 00C0      		rjmp .L24
 831               	.LVL91:
 832               	.L30:
 217:mcp2515.c     **** 	}
 833               		.loc 1 217 0
 834 0332 11E0      		ldi r17,lo8(1)
 835               	.L24:
 248:mcp2515.c     **** 
 249:mcp2515.c     **** }
 836               		.loc 1 249 0
 837 0334 812F      		mov r24,r17
 838               	/* epilogue start */
 839 0336 DF91      		pop r29
 840 0338 CF91      		pop r28
 841               	.LVL92:
 842 033a 1F91      		pop r17
 843 033c 0F91      		pop r16
 844               	.LVL93:
 845 033e FF90      		pop r15
 846 0340 0895      		ret
 847               		.cfi_endproc
 848               	.LFE12:
 850               	.Letext0:
 851               		.file 3 "/usr/avr/include/stdint.h"
 852               		.file 4 "mcp2515.h"
 853               		.file 5 "spi.h"
 854               		.file 6 "uart.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 mcp2515.c
     /tmp/ccKAXncM.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccKAXncM.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccKAXncM.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccKAXncM.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccKAXncM.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccKAXncM.s:12     .text:0000000000000000 mcp_write_reg
     /tmp/ccKAXncM.s:74     .text:000000000000002c mcp_read_reg
     /tmp/ccKAXncM.s:115    .text:0000000000000044 mcp_bit_mod
     /tmp/ccKAXncM.s:183    .text:000000000000007a mcp_init
     /tmp/ccKAXncM.s:309    .text:00000000000000f4 can_send_msg
     /tmp/ccKAXncM.s:646    .text:0000000000000278 mcp_read_rx_stat
     /tmp/ccKAXncM.s:673    .text:0000000000000286 can_get_msg

UNDEFINED SYMBOLS
spi_trans
spi_init
itoa
uart_puts
__do_copy_data
